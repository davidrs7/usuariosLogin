{"ast":null,"code":"import { Directive, TemplateRef, ViewContainerRef, Input, Injectable, ɵɵdefineInjectable, Component, ViewEncapsulation, ElementRef, EventEmitter, ContentChild, ViewChild, Output, HostListener, Renderer2, NgZone, NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { autorun, reaction, computed as computed$1, observable as observable$1, action as action$1 } from 'mobx';\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from '@angular/common';\n\nfunction LoadingComponent_span_0_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementStart(0, \"span\");\n    ɵngcc0.ɵɵtext(1, \"loading...\");\n    ɵngcc0.ɵɵelementEnd();\n  }\n}\n\nconst _c0 = function (a0) {\n  return {\n    $implicit: a0\n  };\n};\n\nfunction TreeViewportComponent_ng_container_0_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementContainerStart(0);\n    ɵngcc0.ɵɵelementStart(1, \"div\");\n    ɵngcc0.ɵɵprojection(2);\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵstyleProp(\"height\", ctx_r0.getTotalHeight());\n  }\n}\n\nconst _c1 = function () {\n  return {\n    dontDetach: true\n  };\n};\n\nconst _c2 = [\"*\"];\nconst _c3 = [\"loadingTemplate\"];\nconst _c4 = [\"treeNodeTemplate\"];\nconst _c5 = [\"treeNodeWrapperTemplate\"];\nconst _c6 = [\"treeNodeFullTemplate\"];\nconst _c7 = [\"viewport\"];\n\nconst _c8 = function (a0, a1, a2, a3) {\n  return {\n    loadingTemplate: a0,\n    treeNodeTemplate: a1,\n    treeNodeWrapperTemplate: a2,\n    treeNodeFullTemplate: a3\n  };\n};\n\nfunction TreeComponent_tree_node_collection_3_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelement(0, \"tree-node-collection\", 4);\n  }\n\n  if (rf & 2) {\n    const ctx_r1 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵproperty(\"nodes\", ctx_r1.treeModel.roots)(\"treeModel\", ctx_r1.treeModel)(\"templates\", ɵngcc0.ɵɵpureFunction4(3, _c8, ctx_r1.loadingTemplate, ctx_r1.treeNodeTemplate, ctx_r1.treeNodeWrapperTemplate, ctx_r1.treeNodeFullTemplate));\n  }\n}\n\nfunction TreeComponent_tree_node_drop_slot_4_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelement(0, \"tree-node-drop-slot\", 5);\n  }\n\n  if (rf & 2) {\n    const ctx_r2 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵproperty(\"dropIndex\", 0)(\"node\", ctx_r2.treeModel.virtualRoot);\n  }\n}\n\nfunction TreeNodeComponent_ng_container_0_div_1_tree_node_drop_slot_1_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelement(0, \"tree-node-drop-slot\", 6);\n  }\n\n  if (rf & 2) {\n    const ctx_r2 = ɵngcc0.ɵɵnextContext(3);\n    ɵngcc0.ɵɵproperty(\"dropIndex\", ctx_r2.node.index)(\"node\", ctx_r2.node.parent);\n  }\n}\n\nfunction TreeNodeComponent_ng_container_0_div_1_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementStart(0, \"div\");\n    ɵngcc0.ɵɵtemplate(1, TreeNodeComponent_ng_container_0_div_1_tree_node_drop_slot_1_Template, 1, 2, \"tree-node-drop-slot\", 3);\n    ɵngcc0.ɵɵelement(2, \"tree-node-wrapper\", 4);\n    ɵngcc0.ɵɵelement(3, \"tree-node-children\", 5);\n    ɵngcc0.ɵɵelement(4, \"tree-node-drop-slot\", 6);\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r1 = ɵngcc0.ɵɵnextContext(2);\n    ɵngcc0.ɵɵclassMap(ctx_r1.node.getClass());\n    ɵngcc0.ɵɵclassProp(\"tree-node\", true)(\"tree-node-expanded\", ctx_r1.node.isExpanded && ctx_r1.node.hasChildren)(\"tree-node-collapsed\", ctx_r1.node.isCollapsed && ctx_r1.node.hasChildren)(\"tree-node-leaf\", ctx_r1.node.isLeaf)(\"tree-node-active\", ctx_r1.node.isActive)(\"tree-node-focused\", ctx_r1.node.isFocused);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngIf\", ctx_r1.index === 0);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"node\", ctx_r1.node)(\"index\", ctx_r1.index)(\"templates\", ctx_r1.templates);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"node\", ctx_r1.node)(\"templates\", ctx_r1.templates);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"dropIndex\", ctx_r1.node.index + 1)(\"node\", ctx_r1.node.parent);\n  }\n}\n\nconst _c9 = function (a0, a1, a2, a3) {\n  return {\n    $implicit: a0,\n    node: a1,\n    index: a2,\n    templates: a3\n  };\n};\n\nfunction TreeNodeComponent_ng_container_0_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementContainerStart(0);\n    ɵngcc0.ɵɵtemplate(1, TreeNodeComponent_ng_container_0_div_1_Template, 5, 22, \"div\", 1);\n    ɵngcc0.ɵɵelementContainer(2, 2);\n    ɵngcc0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngIf\", !ctx_r0.templates.treeNodeFullTemplate);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r0.templates.treeNodeFullTemplate)(\"ngTemplateOutletContext\", ɵngcc0.ɵɵpureFunction4(3, _c9, ctx_r0.node, ctx_r0.node, ctx_r0.index, ctx_r0.templates));\n  }\n}\n\nfunction TreeNodeContent_span_0_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementStart(0, \"span\");\n    ɵngcc0.ɵɵtext(1);\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵtextInterpolate(ctx_r0.node.displayField);\n  }\n}\n\nconst _c10 = function (a0, a1, a2) {\n  return {\n    $implicit: a0,\n    node: a1,\n    index: a2\n  };\n};\n\nfunction TreeNodeExpanderComponent_ng_container_0_span_1_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r4 = ɵngcc0.ɵɵgetCurrentView();\n\n    ɵngcc0.ɵɵelementStart(0, \"span\", 3);\n    ɵngcc0.ɵɵlistener(\"click\", function TreeNodeExpanderComponent_ng_container_0_span_1_Template_span_click_0_listener($event) {\n      ɵngcc0.ɵɵrestoreView(_r4);\n      const ctx_r3 = ɵngcc0.ɵɵnextContext(2);\n      return ctx_r3.node.mouseAction(\"expanderClick\", $event);\n    });\n    ɵngcc0.ɵɵelement(1, \"span\", 4);\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r1 = ɵngcc0.ɵɵnextContext(2);\n    ɵngcc0.ɵɵclassProp(\"toggle-children-wrapper-expanded\", ctx_r1.node.isExpanded)(\"toggle-children-wrapper-collapsed\", ctx_r1.node.isCollapsed);\n  }\n}\n\nfunction TreeNodeExpanderComponent_ng_container_0_span_2_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelement(0, \"span\", 5);\n  }\n}\n\nfunction TreeNodeExpanderComponent_ng_container_0_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementContainerStart(0);\n    ɵngcc0.ɵɵtemplate(1, TreeNodeExpanderComponent_ng_container_0_span_1_Template, 2, 4, \"span\", 1);\n    ɵngcc0.ɵɵtemplate(2, TreeNodeExpanderComponent_ng_container_0_span_2_Template, 1, 0, \"span\", 2);\n    ɵngcc0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngIf\", ctx_r0.node.hasChildren);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngIf\", !ctx_r0.node.hasChildren);\n  }\n}\n\nfunction TreeNodeChildrenComponent_ng_container_0_div_1_tree_node_collection_1_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelement(0, \"tree-node-collection\", 4);\n  }\n\n  if (rf & 2) {\n    const ctx_r2 = ɵngcc0.ɵɵnextContext(3);\n    ɵngcc0.ɵɵproperty(\"nodes\", ctx_r2.node.children)(\"templates\", ctx_r2.templates)(\"treeModel\", ctx_r2.node.treeModel);\n  }\n}\n\nfunction TreeNodeChildrenComponent_ng_container_0_div_1_tree_loading_component_2_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelement(0, \"tree-loading-component\", 5);\n  }\n\n  if (rf & 2) {\n    const ctx_r3 = ɵngcc0.ɵɵnextContext(3);\n    ɵngcc0.ɵɵstyleProp(\"padding-left\", ctx_r3.node.getNodePadding());\n    ɵngcc0.ɵɵproperty(\"template\", ctx_r3.templates.loadingTemplate)(\"node\", ctx_r3.node);\n  }\n}\n\nfunction TreeNodeChildrenComponent_ng_container_0_div_1_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementStart(0, \"div\");\n    ɵngcc0.ɵɵtemplate(1, TreeNodeChildrenComponent_ng_container_0_div_1_tree_node_collection_1_Template, 1, 3, \"tree-node-collection\", 2);\n    ɵngcc0.ɵɵtemplate(2, TreeNodeChildrenComponent_ng_container_0_div_1_tree_loading_component_2_Template, 1, 4, \"tree-loading-component\", 3);\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r1 = ɵngcc0.ɵɵnextContext(2);\n    ɵngcc0.ɵɵclassProp(\"tree-children\", true)(\"tree-children-no-padding\", ctx_r1.node.options.levelPadding);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngIf\", ctx_r1.node.children);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngIf\", !ctx_r1.node.children);\n  }\n}\n\nfunction TreeNodeChildrenComponent_ng_container_0_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementContainerStart(0);\n    ɵngcc0.ɵɵtemplate(1, TreeNodeChildrenComponent_ng_container_0_div_1_Template, 3, 6, \"div\", 1);\n    ɵngcc0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"treeAnimateOpen\", ctx_r0.node.isExpanded)(\"treeAnimateOpenSpeed\", ctx_r0.node.options.animateSpeed)(\"treeAnimateOpenAcceleration\", ctx_r0.node.options.animateAcceleration)(\"treeAnimateOpenEnabled\", ctx_r0.node.options.animateExpand);\n  }\n}\n\nfunction TreeNodeCollectionComponent_ng_container_0_tree_node_2_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelement(0, \"tree-node\", 2);\n  }\n\n  if (rf & 2) {\n    const node_r2 = ctx.$implicit;\n    const i_r3 = ctx.index;\n    const ctx_r1 = ɵngcc0.ɵɵnextContext(2);\n    ɵngcc0.ɵɵproperty(\"node\", node_r2)(\"index\", i_r3)(\"templates\", ctx_r1.templates);\n  }\n}\n\nfunction TreeNodeCollectionComponent_ng_container_0_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementContainerStart(0);\n    ɵngcc0.ɵɵelementStart(1, \"div\");\n    ɵngcc0.ɵɵtemplate(2, TreeNodeCollectionComponent_ng_container_0_tree_node_2_Template, 1, 3, \"tree-node\", 1);\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵstyleProp(\"margin-top\", ctx_r0.marginTop);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngForOf\", ctx_r0.viewportNodes)(\"ngForTrackBy\", ctx_r0.trackNode);\n  }\n}\n\nfunction TreeNodeWrapperComponent_div_0_tree_node_checkbox_1_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelement(0, \"tree-node-checkbox\", 4);\n  }\n\n  if (rf & 2) {\n    const ctx_r1 = ɵngcc0.ɵɵnextContext(2);\n    ɵngcc0.ɵɵproperty(\"node\", ctx_r1.node);\n  }\n}\n\nfunction TreeNodeWrapperComponent_div_0_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r3 = ɵngcc0.ɵɵgetCurrentView();\n\n    ɵngcc0.ɵɵelementStart(0, \"div\", 2);\n    ɵngcc0.ɵɵtemplate(1, TreeNodeWrapperComponent_div_0_tree_node_checkbox_1_Template, 1, 1, \"tree-node-checkbox\", 3);\n    ɵngcc0.ɵɵelement(2, \"tree-node-expander\", 4);\n    ɵngcc0.ɵɵelementStart(3, \"div\", 5);\n    ɵngcc0.ɵɵlistener(\"click\", function TreeNodeWrapperComponent_div_0_Template_div_click_3_listener($event) {\n      ɵngcc0.ɵɵrestoreView(_r3);\n      const ctx_r2 = ɵngcc0.ɵɵnextContext();\n      return ctx_r2.node.mouseAction(\"click\", $event);\n    })(\"dblclick\", function TreeNodeWrapperComponent_div_0_Template_div_dblclick_3_listener($event) {\n      ɵngcc0.ɵɵrestoreView(_r3);\n      const ctx_r4 = ɵngcc0.ɵɵnextContext();\n      return ctx_r4.node.mouseAction(\"dblClick\", $event);\n    })(\"mouseover\", function TreeNodeWrapperComponent_div_0_Template_div_mouseover_3_listener($event) {\n      ɵngcc0.ɵɵrestoreView(_r3);\n      const ctx_r5 = ɵngcc0.ɵɵnextContext();\n      return ctx_r5.node.mouseAction(\"mouseOver\", $event);\n    })(\"mouseout\", function TreeNodeWrapperComponent_div_0_Template_div_mouseout_3_listener($event) {\n      ɵngcc0.ɵɵrestoreView(_r3);\n      const ctx_r6 = ɵngcc0.ɵɵnextContext();\n      return ctx_r6.node.mouseAction(\"mouseOut\", $event);\n    })(\"contextmenu\", function TreeNodeWrapperComponent_div_0_Template_div_contextmenu_3_listener($event) {\n      ɵngcc0.ɵɵrestoreView(_r3);\n      const ctx_r7 = ɵngcc0.ɵɵnextContext();\n      return ctx_r7.node.mouseAction(\"contextMenu\", $event);\n    })(\"treeDrop\", function TreeNodeWrapperComponent_div_0_Template_div_treeDrop_3_listener($event) {\n      ɵngcc0.ɵɵrestoreView(_r3);\n      const ctx_r8 = ɵngcc0.ɵɵnextContext();\n      return ctx_r8.node.onDrop($event);\n    })(\"treeDropDragOver\", function TreeNodeWrapperComponent_div_0_Template_div_treeDropDragOver_3_listener($event) {\n      ɵngcc0.ɵɵrestoreView(_r3);\n      const ctx_r9 = ɵngcc0.ɵɵnextContext();\n      return ctx_r9.node.mouseAction(\"dragOver\", $event);\n    })(\"treeDropDragLeave\", function TreeNodeWrapperComponent_div_0_Template_div_treeDropDragLeave_3_listener($event) {\n      ɵngcc0.ɵɵrestoreView(_r3);\n      const ctx_r10 = ɵngcc0.ɵɵnextContext();\n      return ctx_r10.node.mouseAction(\"dragLeave\", $event);\n    })(\"treeDropDragEnter\", function TreeNodeWrapperComponent_div_0_Template_div_treeDropDragEnter_3_listener($event) {\n      ɵngcc0.ɵɵrestoreView(_r3);\n      const ctx_r11 = ɵngcc0.ɵɵnextContext();\n      return ctx_r11.node.mouseAction(\"dragEnter\", $event);\n    });\n    ɵngcc0.ɵɵelement(4, \"tree-node-content\", 6);\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵstyleProp(\"padding-left\", ctx_r0.node.getNodePadding());\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngIf\", ctx_r0.node.options.useCheckbox);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"node\", ctx_r0.node);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵclassProp(\"node-content-wrapper-active\", ctx_r0.node.isActive)(\"node-content-wrapper-focused\", ctx_r0.node.isFocused);\n    ɵngcc0.ɵɵproperty(\"treeAllowDrop\", ctx_r0.node.allowDrop)(\"allowDragoverStyling\", ctx_r0.node.allowDragoverStyling())(\"treeDrag\", ctx_r0.node)(\"treeDragEnabled\", ctx_r0.node.allowDrag());\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"node\", ctx_r0.node)(\"index\", ctx_r0.index)(\"template\", ctx_r0.templates.treeNodeTemplate);\n  }\n}\n\nfunction TreeNodeCheckboxComponent_ng_container_0_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r2 = ɵngcc0.ɵɵgetCurrentView();\n\n    ɵngcc0.ɵɵelementContainerStart(0);\n    ɵngcc0.ɵɵelementStart(1, \"input\", 1);\n    ɵngcc0.ɵɵlistener(\"click\", function TreeNodeCheckboxComponent_ng_container_0_Template_input_click_1_listener($event) {\n      ɵngcc0.ɵɵrestoreView(_r2);\n      const ctx_r1 = ɵngcc0.ɵɵnextContext();\n      return ctx_r1.node.mouseAction(\"checkboxClick\", $event);\n    });\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"checked\", ctx_r0.node.isSelected)(\"indeterminate\", ctx_r0.node.isPartiallySelected);\n  }\n}\n\nlet TreeMobxAutorunDirective = /*#__PURE__*/(() => {\n  class TreeMobxAutorunDirective {\n    constructor(templateRef, viewContainer) {\n      this.templateRef = templateRef;\n      this.viewContainer = viewContainer;\n      this.templateBindings = {};\n    }\n\n    ngOnInit() {\n      this.view = this.viewContainer.createEmbeddedView(this.templateRef);\n\n      if (this.dispose) {\n        this.dispose();\n      }\n\n      if (this.shouldDetach()) {\n        this.view.detach();\n      }\n\n      this.autoDetect(this.view);\n    }\n\n    shouldDetach() {\n      return this.treeMobxAutorun && this.treeMobxAutorun.detach;\n    }\n\n    autoDetect(view) {\n      this.dispose = autorun(() => view.detectChanges());\n    }\n\n    ngOnDestroy() {\n      if (this.dispose) {\n        this.dispose();\n      }\n    }\n\n  }\n\n  TreeMobxAutorunDirective.ɵfac = function TreeMobxAutorunDirective_Factory(t) {\n    return new (t || TreeMobxAutorunDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef));\n  };\n\n  TreeMobxAutorunDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: TreeMobxAutorunDirective,\n    selectors: [[\"\", \"treeMobxAutorun\", \"\"]],\n    inputs: {\n      treeMobxAutorun: \"treeMobxAutorun\"\n    }\n  });\n  /** @nocollapse */\n\n  return TreeMobxAutorunDirective;\n})();\nconst KEYS = {\n  LEFT: 37,\n  UP: 38,\n  RIGHT: 39,\n  DOWN: 40,\n  ENTER: 13,\n  SPACE: 32,\n  CONTEXT_MENU: 32\n};\n\nconst ɵ0 = (tree, node, $event) => node && node.toggleActivated(),\n      ɵ1 = (tree, node, $event) => node && node.toggleActivated(true),\n      ɵ2 = (tree, node, $event) => node && node.toggleSelected(),\n      ɵ3 = (tree, node, $event) => node.setIsActive(true),\n      ɵ4 = (tree, node, $event) => node.setIsActive(false),\n      ɵ5 = (tree, node, $event) => node.setIsSelected(true),\n      ɵ6 = (tree, node, $event) => node.setIsSelected(false),\n      ɵ7 = (tree, node, $event) => node.focus(),\n      ɵ8 = (tree, node, $event) => node.hasChildren && node.toggleExpanded(),\n      ɵ9 = (tree, node, $event) => node.expand(),\n      ɵ10 = (tree, node, $event) => node.collapse(),\n      ɵ11 = (tree, node, $event) => tree.focusDrillDown(),\n      ɵ12 = (tree, node, $event) => tree.focusDrillUp(),\n      ɵ13 = (tree, node, $event) => tree.focusNextNode(),\n      ɵ14 = (tree, node, $event) => tree.focusPreviousNode(),\n      ɵ15 = (tree, node, $event, {\n  from,\n  to\n}) => {\n  // default action assumes from = node, to = {parent, index}\n  if ($event.ctrlKey) {\n    tree.copyNode(from, to);\n  } else {\n    tree.moveNode(from, to);\n  }\n};\n\nconst TREE_ACTIONS = {\n  TOGGLE_ACTIVE: ɵ0,\n  TOGGLE_ACTIVE_MULTI: ɵ1,\n  TOGGLE_SELECTED: ɵ2,\n  ACTIVATE: ɵ3,\n  DEACTIVATE: ɵ4,\n  SELECT: ɵ5,\n  DESELECT: ɵ6,\n  FOCUS: ɵ7,\n  TOGGLE_EXPANDED: ɵ8,\n  EXPAND: ɵ9,\n  COLLAPSE: ɵ10,\n  DRILL_DOWN: ɵ11,\n  DRILL_UP: ɵ12,\n  NEXT_NODE: ɵ13,\n  PREVIOUS_NODE: ɵ14,\n  MOVE_NODE: ɵ15\n};\nconst defaultActionMapping = {\n  mouse: {\n    click: TREE_ACTIONS.TOGGLE_ACTIVE,\n    dblClick: null,\n    contextMenu: null,\n    expanderClick: TREE_ACTIONS.TOGGLE_EXPANDED,\n    checkboxClick: TREE_ACTIONS.TOGGLE_SELECTED,\n    drop: TREE_ACTIONS.MOVE_NODE\n  },\n  keys: {\n    [KEYS.RIGHT]: TREE_ACTIONS.DRILL_DOWN,\n    [KEYS.LEFT]: TREE_ACTIONS.DRILL_UP,\n    [KEYS.DOWN]: TREE_ACTIONS.NEXT_NODE,\n    [KEYS.UP]: TREE_ACTIONS.PREVIOUS_NODE,\n    [KEYS.SPACE]: TREE_ACTIONS.TOGGLE_ACTIVE,\n    [KEYS.ENTER]: TREE_ACTIONS.TOGGLE_ACTIVE\n  }\n};\n\nclass TreeOptions {\n  constructor(options = {}) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31, _32, _33, _34, _35;\n\n    this.options = options;\n    this.actionMapping = {\n      mouse: {\n        click: (_d = (_c = (_b = (_a = this.options) === null || _a === void 0 ? void 0 : _a.actionMapping) === null || _b === void 0 ? void 0 : _b.mouse) === null || _c === void 0 ? void 0 : _c.click) !== null && _d !== void 0 ? _d : defaultActionMapping.mouse.click,\n        dblClick: (_h = (_g = (_f = (_e = this.options) === null || _e === void 0 ? void 0 : _e.actionMapping) === null || _f === void 0 ? void 0 : _f.mouse) === null || _g === void 0 ? void 0 : _g.dblClick) !== null && _h !== void 0 ? _h : defaultActionMapping.mouse.dblClick,\n        contextMenu: (_m = (_l = (_k = (_j = this.options) === null || _j === void 0 ? void 0 : _j.actionMapping) === null || _k === void 0 ? void 0 : _k.mouse) === null || _l === void 0 ? void 0 : _l.contextMenu) !== null && _m !== void 0 ? _m : defaultActionMapping.mouse.contextMenu,\n        expanderClick: (_r = (_q = (_p = (_o = this.options) === null || _o === void 0 ? void 0 : _o.actionMapping) === null || _p === void 0 ? void 0 : _p.mouse) === null || _q === void 0 ? void 0 : _q.expanderClick) !== null && _r !== void 0 ? _r : defaultActionMapping.mouse.expanderClick,\n        checkboxClick: (_v = (_u = (_t = (_s = this.options) === null || _s === void 0 ? void 0 : _s.actionMapping) === null || _t === void 0 ? void 0 : _t.mouse) === null || _u === void 0 ? void 0 : _u.checkboxClick) !== null && _v !== void 0 ? _v : defaultActionMapping.mouse.checkboxClick,\n        drop: (_z = (_y = (_x = (_w = this.options) === null || _w === void 0 ? void 0 : _w.actionMapping) === null || _x === void 0 ? void 0 : _x.mouse) === null || _y === void 0 ? void 0 : _y.drop) !== null && _z !== void 0 ? _z : defaultActionMapping.mouse.drop,\n        dragStart: (_3 = (_2 = (_1 = (_0 = this.options) === null || _0 === void 0 ? void 0 : _0.actionMapping) === null || _1 === void 0 ? void 0 : _1.mouse) === null || _2 === void 0 ? void 0 : _2.dragStart) !== null && _3 !== void 0 ? _3 : undefined,\n        drag: (_7 = (_6 = (_5 = (_4 = this.options) === null || _4 === void 0 ? void 0 : _4.actionMapping) === null || _5 === void 0 ? void 0 : _5.mouse) === null || _6 === void 0 ? void 0 : _6.drag) !== null && _7 !== void 0 ? _7 : undefined,\n        dragEnd: (_11 = (_10 = (_9 = (_8 = this.options) === null || _8 === void 0 ? void 0 : _8.actionMapping) === null || _9 === void 0 ? void 0 : _9.mouse) === null || _10 === void 0 ? void 0 : _10.dragEnd) !== null && _11 !== void 0 ? _11 : undefined,\n        dragOver: (_15 = (_14 = (_13 = (_12 = this.options) === null || _12 === void 0 ? void 0 : _12.actionMapping) === null || _13 === void 0 ? void 0 : _13.mouse) === null || _14 === void 0 ? void 0 : _14.dragOver) !== null && _15 !== void 0 ? _15 : undefined,\n        dragLeave: (_19 = (_18 = (_17 = (_16 = this.options) === null || _16 === void 0 ? void 0 : _16.actionMapping) === null || _17 === void 0 ? void 0 : _17.mouse) === null || _18 === void 0 ? void 0 : _18.dragLeave) !== null && _19 !== void 0 ? _19 : undefined,\n        dragEnter: (_23 = (_22 = (_21 = (_20 = this.options) === null || _20 === void 0 ? void 0 : _20.actionMapping) === null || _21 === void 0 ? void 0 : _21.mouse) === null || _22 === void 0 ? void 0 : _22.dragEnter) !== null && _23 !== void 0 ? _23 : undefined,\n        mouseOver: (_27 = (_26 = (_25 = (_24 = this.options) === null || _24 === void 0 ? void 0 : _24.actionMapping) === null || _25 === void 0 ? void 0 : _25.mouse) === null || _26 === void 0 ? void 0 : _26.mouseOver) !== null && _27 !== void 0 ? _27 : undefined,\n        mouseOut: (_31 = (_30 = (_29 = (_28 = this.options) === null || _28 === void 0 ? void 0 : _28.actionMapping) === null || _29 === void 0 ? void 0 : _29.mouse) === null || _30 === void 0 ? void 0 : _30.mouseOut) !== null && _31 !== void 0 ? _31 : undefined\n      },\n      keys: {\n        [KEYS.RIGHT]: TREE_ACTIONS.DRILL_DOWN,\n        [KEYS.LEFT]: TREE_ACTIONS.DRILL_UP,\n        [KEYS.DOWN]: TREE_ACTIONS.NEXT_NODE,\n        [KEYS.UP]: TREE_ACTIONS.PREVIOUS_NODE,\n        [KEYS.SPACE]: TREE_ACTIONS.TOGGLE_ACTIVE,\n        [KEYS.ENTER]: TREE_ACTIONS.TOGGLE_ACTIVE\n      }\n    };\n\n    if ((_33 = (_32 = this.options) === null || _32 === void 0 ? void 0 : _32.actionMapping) === null || _33 === void 0 ? void 0 : _33.keys) {\n      this.actionMapping.keys = Object.assign(Object.assign({}, this.actionMapping.keys), this.options.actionMapping.keys);\n    }\n\n    if (options.rtl) {\n      this.actionMapping.keys[KEYS.RIGHT] = ((_34 = options.actionMapping) === null || _34 === void 0 ? void 0 : _34.keys[KEYS.RIGHT]) || TREE_ACTIONS.DRILL_UP;\n      this.actionMapping.keys[KEYS.LEFT] = ((_35 = options.actionMapping) === null || _35 === void 0 ? void 0 : _35.keys[KEYS.LEFT]) || TREE_ACTIONS.DRILL_DOWN;\n    }\n  }\n\n  get hasChildrenField() {\n    return this.options.hasChildrenField || 'hasChildren';\n  }\n\n  get childrenField() {\n    return this.options.childrenField || 'children';\n  }\n\n  get displayField() {\n    return this.options.displayField || 'name';\n  }\n\n  get idField() {\n    return this.options.idField || 'id';\n  }\n\n  get isExpandedField() {\n    return this.options.isExpandedField || 'isExpanded';\n  }\n\n  get getChildren() {\n    return this.options.getChildren;\n  }\n\n  get levelPadding() {\n    return this.options.levelPadding || 0;\n  }\n\n  get useVirtualScroll() {\n    return this.options.useVirtualScroll;\n  }\n\n  get animateExpand() {\n    return this.options.animateExpand;\n  }\n\n  get animateSpeed() {\n    return this.options.animateSpeed || 1;\n  }\n\n  get animateAcceleration() {\n    return this.options.animateAcceleration || 1.2;\n  }\n\n  get scrollOnActivate() {\n    return this.options.scrollOnActivate === undefined ? true : this.options.scrollOnActivate;\n  }\n\n  get rtl() {\n    return !!this.options.rtl;\n  }\n\n  get rootId() {\n    return this.options.rootId;\n  }\n\n  get useCheckbox() {\n    return this.options.useCheckbox;\n  }\n\n  get useTriState() {\n    return this.options.useTriState === undefined ? true : this.options.useTriState;\n  }\n\n  get scrollContainer() {\n    return this.options.scrollContainer;\n  }\n\n  get allowDragoverStyling() {\n    return this.options.allowDragoverStyling === undefined ? true : this.options.allowDragoverStyling;\n  }\n\n  getNodeClone(node) {\n    if (this.options.getNodeClone) {\n      return this.options.getNodeClone(node);\n    } // remove id from clone\n    // keeping ie11 compatibility\n\n\n    const nodeClone = Object.assign({}, node.data);\n\n    if (nodeClone.id) {\n      delete nodeClone.id;\n    }\n\n    return nodeClone;\n  }\n\n  allowDrop(element, to, $event) {\n    if (this.options.allowDrop instanceof Function) {\n      return this.options.allowDrop(element, to, $event);\n    } else {\n      return this.options.allowDrop === undefined ? true : this.options.allowDrop;\n    }\n  }\n\n  allowDrag(node) {\n    if (this.options.allowDrag instanceof Function) {\n      return this.options.allowDrag(node);\n    } else {\n      return this.options.allowDrag;\n    }\n  }\n\n  nodeClass(node) {\n    return this.options.nodeClass ? this.options.nodeClass(node) : '';\n  }\n\n  nodeHeight(node) {\n    if (node.data.virtual) {\n      return 0;\n    }\n\n    let nodeHeight = this.options.nodeHeight || 22;\n\n    if (typeof nodeHeight === 'function') {\n      nodeHeight = nodeHeight(node);\n    } // account for drop slots:\n\n\n    return nodeHeight + (node.index === 0 ? 2 : 1) * this.dropSlotHeight;\n  }\n\n  get dropSlotHeight() {\n    return typeof this.options.dropSlotHeight === 'number' ? this.options.dropSlotHeight : 2;\n  }\n\n}\n\nconst TREE_EVENTS = {\n  toggleExpanded: 'toggleExpanded',\n  activate: 'activate',\n  deactivate: 'deactivate',\n  nodeActivate: 'nodeActivate',\n  nodeDeactivate: 'nodeDeactivate',\n  select: 'select',\n  deselect: 'deselect',\n  focus: 'focus',\n  blur: 'blur',\n  initialized: 'initialized',\n  updateData: 'updateData',\n  moveNode: 'moveNode',\n  copyNode: 'copyNode',\n  event: 'event',\n  loadNodeChildren: 'loadNodeChildren',\n  changeFilter: 'changeFilter',\n  stateChange: 'stateChange'\n};\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nvar __metadata = this && this.__metadata || function (k, v) {\n  if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\n\nlet TreeNode = /*#__PURE__*/(() => {\n  class TreeNode {\n    constructor(data, parent, treeModel, index) {\n      this.data = data;\n      this.parent = parent;\n      this.treeModel = treeModel;\n      this.position = 0;\n\n      this.allowDrop = (element, $event) => {\n        return this.options.allowDrop(element, {\n          parent: this,\n          index: 0\n        }, $event);\n      };\n\n      this.allowDragoverStyling = () => {\n        return this.options.allowDragoverStyling;\n      };\n\n      if (this.id === undefined || this.id === null) {\n        this.id = uuid();\n      } // Make sure there's a unique id without overriding existing ids to work with immutable data structures\n\n\n      this.index = index;\n\n      if (this.getField('children')) {\n        this._initChildren();\n      }\n\n      this.autoLoadChildren();\n    }\n\n    get isHidden() {\n      return this.treeModel.isHidden(this);\n    }\n\n    get isExpanded() {\n      return this.treeModel.isExpanded(this);\n    }\n\n    get isActive() {\n      return this.treeModel.isActive(this);\n    }\n\n    get isFocused() {\n      return this.treeModel.isNodeFocused(this);\n    }\n\n    get isSelected() {\n      if (this.isSelectable()) {\n        return this.treeModel.isSelected(this);\n      } else {\n        return this.children.some(node => node.isSelected);\n      }\n    }\n\n    get isAllSelected() {\n      if (this.isSelectable()) {\n        return this.treeModel.isSelected(this);\n      } else {\n        return this.children.every(node => node.isAllSelected);\n      }\n    }\n\n    get isPartiallySelected() {\n      return this.isSelected && !this.isAllSelected;\n    }\n\n    get level() {\n      return this.parent ? this.parent.level + 1 : 0;\n    }\n\n    get path() {\n      return this.parent ? [...this.parent.path, this.id] : [];\n    }\n\n    get elementRef() {\n      throw `Element Ref is no longer supported since introducing virtual scroll\\n\n      You may use a template to obtain a reference to the element`;\n    }\n\n    get originalNode() {\n      return this._originalNode;\n    }\n\n    // helper get functions:\n    get hasChildren() {\n      return !!(this.getField('hasChildren') || this.children && this.children.length > 0);\n    }\n\n    get isCollapsed() {\n      return !this.isExpanded;\n    }\n\n    get isLeaf() {\n      return !this.hasChildren;\n    }\n\n    get isRoot() {\n      return this.parent.data.virtual;\n    }\n\n    get realParent() {\n      return this.isRoot ? null : this.parent;\n    } // proxy functions:\n\n\n    get options() {\n      return this.treeModel.options;\n    }\n\n    fireEvent(event) {\n      this.treeModel.fireEvent(event);\n    } // field accessors:\n\n\n    get displayField() {\n      return this.getField('display');\n    }\n\n    get id() {\n      return this.getField('id');\n    }\n\n    set id(value) {\n      this.setField('id', value);\n    }\n\n    getField(key) {\n      return this.data[this.options[`${key}Field`]];\n    }\n\n    setField(key, value) {\n      this.data[this.options[`${key}Field`]] = value;\n    } // traversing:\n\n\n    _findAdjacentSibling(steps, skipHidden = false) {\n      const siblings = this._getParentsChildren(skipHidden);\n\n      const index = siblings.indexOf(this);\n      return siblings.length > index + steps ? siblings[index + steps] : null;\n    }\n\n    findNextSibling(skipHidden = false) {\n      return this._findAdjacentSibling(+1, skipHidden);\n    }\n\n    findPreviousSibling(skipHidden = false) {\n      return this._findAdjacentSibling(-1, skipHidden);\n    }\n\n    getVisibleChildren() {\n      return this.visibleChildren;\n    }\n\n    get visibleChildren() {\n      return (this.children || []).filter(node => !node.isHidden);\n    }\n\n    getFirstChild(skipHidden = false) {\n      let children = skipHidden ? this.visibleChildren : this.children;\n      return children != null && children.length ? children[0] : null;\n    }\n\n    getLastChild(skipHidden = false) {\n      let children = skipHidden ? this.visibleChildren : this.children;\n      return children != null && children.length ? children[children.length - 1] : null;\n    }\n\n    findNextNode(goInside = true, skipHidden = false) {\n      return goInside && this.isExpanded && this.getFirstChild(skipHidden) || this.findNextSibling(skipHidden) || this.parent && this.parent.findNextNode(false, skipHidden);\n    }\n\n    findPreviousNode(skipHidden = false) {\n      let previousSibling = this.findPreviousSibling(skipHidden);\n\n      if (!previousSibling) {\n        return this.realParent;\n      }\n\n      return previousSibling._getLastOpenDescendant(skipHidden);\n    }\n\n    _getLastOpenDescendant(skipHidden = false) {\n      const lastChild = this.getLastChild(skipHidden);\n      return this.isCollapsed || !lastChild ? this : lastChild._getLastOpenDescendant(skipHidden);\n    }\n\n    _getParentsChildren(skipHidden = false) {\n      const children = this.parent && (skipHidden ? this.parent.getVisibleChildren() : this.parent.children);\n      return children || [];\n    }\n\n    getIndexInParent(skipHidden = false) {\n      return this._getParentsChildren(skipHidden).indexOf(this);\n    }\n\n    isDescendantOf(node) {\n      if (this === node) return true;else return this.parent && this.parent.isDescendantOf(node);\n    }\n\n    getNodePadding() {\n      return this.options.levelPadding * (this.level - 1) + 'px';\n    }\n\n    getClass() {\n      return [this.options.nodeClass(this), `tree-node-level-${this.level}`].join(' ');\n    }\n\n    onDrop($event) {\n      this.mouseAction('drop', $event.event, {\n        from: $event.element,\n        to: {\n          parent: this,\n          index: 0,\n          dropOnNode: true\n        }\n      });\n    }\n\n    allowDrag() {\n      return this.options.allowDrag(this);\n    } // helper methods:\n\n\n    loadNodeChildren() {\n      if (!this.options.getChildren) {\n        return Promise.resolve(); // Not getChildren method - for using redux\n      }\n\n      return Promise.resolve(this.options.getChildren(this)).then(children => {\n        if (children) {\n          this.setField('children', children);\n\n          this._initChildren();\n\n          if (this.options.useTriState && this.treeModel.isSelected(this)) {\n            this.setIsSelected(true);\n          }\n\n          this.children.forEach(child => {\n            if (child.getField('isExpanded') && child.hasChildren) {\n              child.expand();\n            }\n          });\n        }\n      }).then(() => {\n        this.fireEvent({\n          eventName: TREE_EVENTS.loadNodeChildren,\n          node: this\n        });\n      });\n    }\n\n    expand() {\n      if (!this.isExpanded) {\n        this.toggleExpanded();\n      }\n\n      return this;\n    }\n\n    collapse() {\n      if (this.isExpanded) {\n        this.toggleExpanded();\n      }\n\n      return this;\n    }\n\n    doForAll(fn) {\n      Promise.resolve(fn(this)).then(() => {\n        if (this.children) {\n          this.children.forEach(child => child.doForAll(fn));\n        }\n      });\n    }\n\n    expandAll() {\n      this.doForAll(node => node.expand());\n    }\n\n    collapseAll() {\n      this.doForAll(node => node.collapse());\n    }\n\n    ensureVisible() {\n      if (this.realParent) {\n        this.realParent.expand();\n        this.realParent.ensureVisible();\n      }\n\n      return this;\n    }\n\n    toggleExpanded() {\n      this.setIsExpanded(!this.isExpanded);\n      return this;\n    }\n\n    setIsExpanded(value) {\n      if (this.hasChildren) {\n        this.treeModel.setExpandedNode(this, value);\n      }\n\n      return this;\n    }\n\n    autoLoadChildren() {\n      this.handler = reaction(() => this.isExpanded, isExpanded => {\n        if (!this.children && this.hasChildren && isExpanded) {\n          this.loadNodeChildren();\n        }\n      }, {\n        fireImmediately: true\n      });\n    }\n\n    dispose() {\n      if (this.children) {\n        this.children.forEach(child => child.dispose());\n      }\n\n      if (this.handler) {\n        this.handler();\n      }\n\n      this.parent = null;\n      this.children = null;\n    }\n\n    setIsActive(value, multi = false) {\n      this.treeModel.setActiveNode(this, value, multi);\n\n      if (value) {\n        this.focus(this.options.scrollOnActivate);\n      }\n\n      return this;\n    }\n\n    isSelectable() {\n      return this.isLeaf || !this.children || !this.options.useTriState;\n    }\n\n    setIsSelected(value) {\n      if (this.isSelectable()) {\n        this.treeModel.setSelectedNode(this, value);\n      } else {\n        this.visibleChildren.forEach(child => child.setIsSelected(value));\n      }\n\n      return this;\n    }\n\n    toggleSelected() {\n      this.setIsSelected(!this.isSelected);\n      return this;\n    }\n\n    toggleActivated(multi = false) {\n      this.setIsActive(!this.isActive, multi);\n      return this;\n    }\n\n    setActiveAndVisible(multi = false) {\n      this.setIsActive(true, multi).ensureVisible();\n      setTimeout(this.scrollIntoView.bind(this));\n      return this;\n    }\n\n    scrollIntoView(force = false) {\n      this.treeModel.virtualScroll.scrollIntoView(this, force);\n    }\n\n    focus(scroll = true) {\n      let previousNode = this.treeModel.getFocusedNode();\n      this.treeModel.setFocusedNode(this);\n\n      if (scroll) {\n        this.scrollIntoView();\n      }\n\n      if (previousNode) {\n        this.fireEvent({\n          eventName: TREE_EVENTS.blur,\n          node: previousNode\n        });\n      }\n\n      this.fireEvent({\n        eventName: TREE_EVENTS.focus,\n        node: this\n      });\n      return this;\n    }\n\n    blur() {\n      let previousNode = this.treeModel.getFocusedNode();\n      this.treeModel.setFocusedNode(null);\n\n      if (previousNode) {\n        this.fireEvent({\n          eventName: TREE_EVENTS.blur,\n          node: this\n        });\n      }\n\n      return this;\n    }\n\n    setIsHidden(value) {\n      this.treeModel.setIsHidden(this, value);\n    }\n\n    hide() {\n      this.setIsHidden(true);\n    }\n\n    show() {\n      this.setIsHidden(false);\n    }\n\n    mouseAction(actionName, $event, data = null) {\n      this.treeModel.setFocus(true);\n      const actionMapping = this.options.actionMapping.mouse;\n      const mouseAction = actionMapping[actionName];\n\n      if (mouseAction) {\n        mouseAction(this.treeModel, this, $event, data);\n      }\n    }\n\n    getSelfHeight() {\n      return this.options.nodeHeight(this);\n    }\n\n    _initChildren() {\n      this.children = this.getField('children').map((c, index) => new TreeNode(c, this, this.treeModel, index));\n    }\n\n  }\n\n  __decorate([computed$1, __metadata(\"design:type\", Object), __metadata(\"design:paramtypes\", [])], TreeNode.prototype, \"isHidden\", null);\n\n  __decorate([computed$1, __metadata(\"design:type\", Object), __metadata(\"design:paramtypes\", [])], TreeNode.prototype, \"isExpanded\", null);\n\n  __decorate([computed$1, __metadata(\"design:type\", Object), __metadata(\"design:paramtypes\", [])], TreeNode.prototype, \"isActive\", null);\n\n  __decorate([computed$1, __metadata(\"design:type\", Object), __metadata(\"design:paramtypes\", [])], TreeNode.prototype, \"isFocused\", null);\n\n  __decorate([computed$1, __metadata(\"design:type\", Object), __metadata(\"design:paramtypes\", [])], TreeNode.prototype, \"isSelected\", null);\n\n  __decorate([computed$1, __metadata(\"design:type\", Object), __metadata(\"design:paramtypes\", [])], TreeNode.prototype, \"isAllSelected\", null);\n\n  __decorate([computed$1, __metadata(\"design:type\", Object), __metadata(\"design:paramtypes\", [])], TreeNode.prototype, \"isPartiallySelected\", null);\n\n  __decorate([observable$1, __metadata(\"design:type\", Array)], TreeNode.prototype, \"children\", void 0);\n\n  __decorate([observable$1, __metadata(\"design:type\", Number)], TreeNode.prototype, \"index\", void 0);\n\n  __decorate([observable$1, __metadata(\"design:type\", Object)], TreeNode.prototype, \"position\", void 0);\n\n  __decorate([observable$1, __metadata(\"design:type\", Number)], TreeNode.prototype, \"height\", void 0);\n\n  __decorate([computed$1, __metadata(\"design:type\", Number), __metadata(\"design:paramtypes\", [])], TreeNode.prototype, \"level\", null);\n\n  __decorate([computed$1, __metadata(\"design:type\", Array), __metadata(\"design:paramtypes\", [])], TreeNode.prototype, \"path\", null);\n\n  __decorate([computed$1, __metadata(\"design:type\", Object), __metadata(\"design:paramtypes\", [])], TreeNode.prototype, \"visibleChildren\", null);\n\n  __decorate([action$1, __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [Object]), __metadata(\"design:returntype\", void 0)], TreeNode.prototype, \"setIsSelected\", null);\n\n  __decorate([action$1, __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", []), __metadata(\"design:returntype\", void 0)], TreeNode.prototype, \"_initChildren\", null);\n\n  return TreeNode;\n})();\n\nfunction uuid() {\n  return Math.floor(Math.random() * 10000000000000);\n}\n\nvar __decorate$1 = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nvar __metadata$1 = this && this.__metadata || function (k, v) {\n  if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\n\nlet TreeModel = /*#__PURE__*/(() => {\n  class TreeModel {\n    constructor() {\n      this.options = new TreeOptions();\n      this.eventNames = Object.keys(TREE_EVENTS);\n      this.expandedNodeIds = {};\n      this.selectedLeafNodeIds = {};\n      this.activeNodeIds = {};\n      this.hiddenNodeIds = {};\n      this.focusedNodeId = null;\n      this.firstUpdate = true;\n      this.subscriptions = [];\n    } // events\n\n\n    fireEvent(event) {\n      event.treeModel = this;\n      this.events[event.eventName].emit(event);\n      this.events.event.emit(event);\n    }\n\n    subscribe(eventName, fn) {\n      const subscription = this.events[eventName].subscribe(fn);\n      this.subscriptions.push(subscription);\n    } // getters\n\n\n    getFocusedNode() {\n      return this.focusedNode;\n    }\n\n    getActiveNode() {\n      return this.activeNodes[0];\n    }\n\n    getActiveNodes() {\n      return this.activeNodes;\n    }\n\n    getVisibleRoots() {\n      return this.virtualRoot.visibleChildren;\n    }\n\n    getFirstRoot(skipHidden = false) {\n      const root = skipHidden ? this.getVisibleRoots() : this.roots;\n      return root != null && root.length ? root[0] : null;\n    }\n\n    getLastRoot(skipHidden = false) {\n      const root = skipHidden ? this.getVisibleRoots() : this.roots;\n      return root != null && root.length ? root[root.length - 1] : null;\n    }\n\n    get isFocused() {\n      return TreeModel.focusedTree === this;\n    }\n\n    isNodeFocused(node) {\n      return this.focusedNode === node;\n    }\n\n    isEmptyTree() {\n      return this.roots && this.roots.length === 0;\n    }\n\n    get focusedNode() {\n      return this.focusedNodeId ? this.getNodeById(this.focusedNodeId) : null;\n    }\n\n    get expandedNodes() {\n      const nodes = Object.keys(this.expandedNodeIds).filter(id => this.expandedNodeIds[id]).map(id => this.getNodeById(id));\n      return nodes.filter(Boolean);\n    }\n\n    get activeNodes() {\n      const nodes = Object.keys(this.activeNodeIds).filter(id => this.activeNodeIds[id]).map(id => this.getNodeById(id));\n      return nodes.filter(Boolean);\n    }\n\n    get hiddenNodes() {\n      const nodes = Object.keys(this.hiddenNodeIds).filter(id => this.hiddenNodeIds[id]).map(id => this.getNodeById(id));\n      return nodes.filter(Boolean);\n    }\n\n    get selectedLeafNodes() {\n      const nodes = Object.keys(this.selectedLeafNodeIds).filter(id => this.selectedLeafNodeIds[id]).map(id => this.getNodeById(id));\n      return nodes.filter(Boolean);\n    } // locating nodes\n\n\n    getNodeByPath(path, startNode = null) {\n      if (!path) return null;\n      startNode = startNode || this.virtualRoot;\n      if (path.length === 0) return startNode;\n      if (!startNode.children) return null;\n      const childId = path.shift();\n      const childNode = startNode.children.find(c => c.id === childId);\n      if (!childNode) return null;\n      return this.getNodeByPath(path, childNode);\n    }\n\n    getNodeById(id) {\n      const idStr = id.toString();\n      return this.getNodeBy(node => node.id.toString() === idStr);\n    }\n\n    getNodeBy(predicate, startNode = null) {\n      startNode = startNode || this.virtualRoot;\n      if (!startNode.children) return null;\n      const found = startNode.children.find(predicate);\n\n      if (found) {\n        // found in children\n        return found;\n      } else {\n        // look in children's children\n        for (let child of startNode.children) {\n          const foundInChildren = this.getNodeBy(predicate, child);\n          if (foundInChildren) return foundInChildren;\n        }\n      }\n    }\n\n    isExpanded(node) {\n      return this.expandedNodeIds[node.id];\n    }\n\n    isHidden(node) {\n      return this.hiddenNodeIds[node.id];\n    }\n\n    isActive(node) {\n      return this.activeNodeIds[node.id];\n    }\n\n    isSelected(node) {\n      return this.selectedLeafNodeIds[node.id];\n    }\n\n    ngOnDestroy() {\n      this.dispose();\n      this.unsubscribeAll();\n    }\n\n    dispose() {\n      // Dispose reactions of the replaced nodes\n      if (this.virtualRoot) {\n        this.virtualRoot.dispose();\n      }\n    }\n\n    unsubscribeAll() {\n      this.subscriptions.forEach(subscription => subscription.unsubscribe());\n      this.subscriptions = [];\n    } // actions\n\n\n    setData({\n      nodes,\n      options = null,\n      events = null\n    }) {\n      if (options) {\n        this.options = new TreeOptions(options);\n      }\n\n      if (events) {\n        this.events = events;\n      }\n\n      if (nodes) {\n        this.nodes = nodes;\n      }\n\n      this.update();\n    }\n\n    update() {\n      // Rebuild tree:\n      let virtualRootConfig = {\n        id: this.options.rootId,\n        virtual: true,\n        [this.options.childrenField]: this.nodes\n      };\n      this.dispose();\n      this.virtualRoot = new TreeNode(virtualRootConfig, null, this, 0);\n      this.roots = this.virtualRoot.children; // Fire event:\n\n      if (this.firstUpdate) {\n        if (this.roots) {\n          this.firstUpdate = false;\n\n          this._calculateExpandedNodes();\n        }\n      } else {\n        this.fireEvent({\n          eventName: TREE_EVENTS.updateData\n        });\n      }\n    }\n\n    setFocusedNode(node) {\n      this.focusedNodeId = node ? node.id : null;\n    }\n\n    setFocus(value) {\n      TreeModel.focusedTree = value ? this : null;\n    }\n\n    doForAll(fn) {\n      this.roots.forEach(root => root.doForAll(fn));\n    }\n\n    focusNextNode() {\n      let previousNode = this.getFocusedNode();\n      let nextNode = previousNode ? previousNode.findNextNode(true, true) : this.getFirstRoot(true);\n      if (nextNode) nextNode.focus();\n    }\n\n    focusPreviousNode() {\n      let previousNode = this.getFocusedNode();\n      let nextNode = previousNode ? previousNode.findPreviousNode(true) : this.getLastRoot(true);\n      if (nextNode) nextNode.focus();\n    }\n\n    focusDrillDown() {\n      let previousNode = this.getFocusedNode();\n\n      if (previousNode && previousNode.isCollapsed && previousNode.hasChildren) {\n        previousNode.toggleExpanded();\n      } else {\n        let nextNode = previousNode ? previousNode.getFirstChild(true) : this.getFirstRoot(true);\n        if (nextNode) nextNode.focus();\n      }\n    }\n\n    focusDrillUp() {\n      let previousNode = this.getFocusedNode();\n      if (!previousNode) return;\n\n      if (previousNode.isExpanded) {\n        previousNode.toggleExpanded();\n      } else {\n        let nextNode = previousNode.realParent;\n        if (nextNode) nextNode.focus();\n      }\n    }\n\n    setActiveNode(node, value, multi = false) {\n      if (multi) {\n        this._setActiveNodeMulti(node, value);\n      } else {\n        this._setActiveNodeSingle(node, value);\n      }\n\n      if (value) {\n        node.focus(this.options.scrollOnActivate);\n        this.fireEvent({\n          eventName: TREE_EVENTS.activate,\n          node\n        });\n        this.fireEvent({\n          eventName: TREE_EVENTS.nodeActivate,\n          node\n        }); // For IE11\n      } else {\n        this.fireEvent({\n          eventName: TREE_EVENTS.deactivate,\n          node\n        });\n        this.fireEvent({\n          eventName: TREE_EVENTS.nodeDeactivate,\n          node\n        }); // For IE11\n      }\n    }\n\n    setSelectedNode(node, value) {\n      this.selectedLeafNodeIds = Object.assign({}, this.selectedLeafNodeIds, {\n        [node.id]: value\n      });\n\n      if (value) {\n        node.focus();\n        this.fireEvent({\n          eventName: TREE_EVENTS.select,\n          node\n        });\n      } else {\n        this.fireEvent({\n          eventName: TREE_EVENTS.deselect,\n          node\n        });\n      }\n    }\n\n    setExpandedNode(node, value) {\n      this.expandedNodeIds = Object.assign({}, this.expandedNodeIds, {\n        [node.id]: value\n      });\n      this.fireEvent({\n        eventName: TREE_EVENTS.toggleExpanded,\n        node,\n        isExpanded: value\n      });\n    }\n\n    expandAll() {\n      this.roots.forEach(root => root.expandAll());\n    }\n\n    collapseAll() {\n      this.roots.forEach(root => root.collapseAll());\n    }\n\n    setIsHidden(node, value) {\n      this.hiddenNodeIds = Object.assign({}, this.hiddenNodeIds, {\n        [node.id]: value\n      });\n    }\n\n    setHiddenNodeIds(nodeIds) {\n      this.hiddenNodeIds = nodeIds.reduce((hiddenNodeIds, id) => Object.assign(hiddenNodeIds, {\n        [id]: true\n      }), {});\n    }\n\n    performKeyAction(node, $event) {\n      const keyAction = this.options.actionMapping.keys[$event.keyCode];\n\n      if (keyAction) {\n        $event.preventDefault();\n        keyAction(this, node, $event);\n        return true;\n      } else {\n        return false;\n      }\n    }\n\n    filterNodes(filter, autoShow = true) {\n      let filterFn;\n\n      if (!filter) {\n        return this.clearFilter();\n      } // support function and string filter\n\n\n      if (filter && typeof filter.valueOf() === 'string') {\n        filterFn = node => node.displayField.toLowerCase().indexOf(filter.toLowerCase()) !== -1;\n      } else if (filter && typeof filter === 'function') {\n        filterFn = filter;\n      } else {\n        console.error('Don\\'t know what to do with filter', filter);\n        console.error('Should be either a string or function');\n        return;\n      }\n\n      const ids = {};\n      this.roots.forEach(node => this._filterNode(ids, node, filterFn, autoShow));\n      this.hiddenNodeIds = ids;\n      this.fireEvent({\n        eventName: TREE_EVENTS.changeFilter\n      });\n    }\n\n    clearFilter() {\n      this.hiddenNodeIds = {};\n      this.fireEvent({\n        eventName: TREE_EVENTS.changeFilter\n      });\n    }\n\n    moveNode(node, to) {\n      const fromIndex = node.getIndexInParent();\n      const fromParent = node.parent;\n      if (!this.canMoveNode(node, to, fromIndex)) return;\n      const fromChildren = fromParent.getField('children'); // If node doesn't have children - create children array\n\n      if (!to.parent.getField('children')) {\n        to.parent.setField('children', []);\n      }\n\n      const toChildren = to.parent.getField('children');\n      const originalNode = fromChildren.splice(fromIndex, 1)[0]; // Compensate for index if already removed from parent:\n\n      let toIndex = fromParent === to.parent && to.index > fromIndex ? to.index - 1 : to.index;\n      toChildren.splice(toIndex, 0, originalNode);\n      fromParent.treeModel.update();\n\n      if (to.parent.treeModel !== fromParent.treeModel) {\n        to.parent.treeModel.update();\n      }\n\n      this.fireEvent({\n        eventName: TREE_EVENTS.moveNode,\n        node: originalNode,\n        to: {\n          parent: to.parent.data,\n          index: toIndex\n        },\n        from: {\n          parent: fromParent.data,\n          index: fromIndex\n        }\n      });\n    }\n\n    copyNode(node, to) {\n      const fromIndex = node.getIndexInParent();\n      if (!this.canMoveNode(node, to, fromIndex)) return; // If node doesn't have children - create children array\n\n      if (!to.parent.getField('children')) {\n        to.parent.setField('children', []);\n      }\n\n      const toChildren = to.parent.getField('children');\n      const nodeCopy = this.options.getNodeClone(node);\n      toChildren.splice(to.index, 0, nodeCopy);\n      node.treeModel.update();\n\n      if (to.parent.treeModel !== node.treeModel) {\n        to.parent.treeModel.update();\n      }\n\n      this.fireEvent({\n        eventName: TREE_EVENTS.copyNode,\n        node: nodeCopy,\n        to: {\n          parent: to.parent.data,\n          index: to.index\n        }\n      });\n    }\n\n    getState() {\n      return {\n        expandedNodeIds: this.expandedNodeIds,\n        selectedLeafNodeIds: this.selectedLeafNodeIds,\n        activeNodeIds: this.activeNodeIds,\n        hiddenNodeIds: this.hiddenNodeIds,\n        focusedNodeId: this.focusedNodeId\n      };\n    }\n\n    setState(state) {\n      if (!state) return;\n      Object.assign(this, {\n        expandedNodeIds: state.expandedNodeIds || {},\n        selectedLeafNodeIds: state.selectedLeafNodeIds || {},\n        activeNodeIds: state.activeNodeIds || {},\n        hiddenNodeIds: state.hiddenNodeIds || {},\n        focusedNodeId: state.focusedNodeId\n      });\n    }\n\n    subscribeToState(fn) {\n      autorun(() => fn(this.getState()));\n    }\n\n    canMoveNode(node, to, fromIndex = undefined) {\n      const fromNodeIndex = fromIndex || node.getIndexInParent(); // same node:\n\n      if (node.parent === to.parent && fromIndex === to.index) {\n        return false;\n      }\n\n      return !to.parent.isDescendantOf(node);\n    }\n\n    calculateExpandedNodes() {\n      this._calculateExpandedNodes();\n    } // private methods\n\n\n    _filterNode(ids, node, filterFn, autoShow) {\n      // if node passes function then it's visible\n      let isVisible = filterFn(node);\n\n      if (node.children) {\n        // if one of node's children passes filter then this node is also visible\n        node.children.forEach(child => {\n          if (this._filterNode(ids, child, filterFn, autoShow)) {\n            isVisible = true;\n          }\n        });\n      } // mark node as hidden\n\n\n      if (!isVisible) {\n        ids[node.id] = true;\n      } // auto expand parents to make sure the filtered nodes are visible\n\n\n      if (autoShow && isVisible) {\n        node.ensureVisible();\n      }\n\n      return isVisible;\n    }\n\n    _calculateExpandedNodes(startNode = null) {\n      startNode = startNode || this.virtualRoot;\n\n      if (startNode.data[this.options.isExpandedField]) {\n        this.expandedNodeIds = Object.assign({}, this.expandedNodeIds, {\n          [startNode.id]: true\n        });\n      }\n\n      if (startNode.children) {\n        startNode.children.forEach(child => this._calculateExpandedNodes(child));\n      }\n    }\n\n    _setActiveNodeSingle(node, value) {\n      // Deactivate all other nodes:\n      this.activeNodes.filter(activeNode => activeNode !== node).forEach(activeNode => {\n        this.fireEvent({\n          eventName: TREE_EVENTS.deactivate,\n          node: activeNode\n        });\n        this.fireEvent({\n          eventName: TREE_EVENTS.nodeDeactivate,\n          node: activeNode\n        }); // For IE11\n      });\n\n      if (value) {\n        this.activeNodeIds = {\n          [node.id]: true\n        };\n      } else {\n        this.activeNodeIds = {};\n      }\n    }\n\n    _setActiveNodeMulti(node, value) {\n      this.activeNodeIds = Object.assign({}, this.activeNodeIds, {\n        [node.id]: value\n      });\n    }\n\n  }\n\n  TreeModel.ɵfac = function TreeModel_Factory(t) {\n    return new (t || TreeModel)();\n  };\n\n  TreeModel.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: TreeModel,\n    factory: TreeModel.ɵfac\n  });\n  TreeModel.focusedTree = null;\n  return TreeModel;\n})();\n\n__decorate$1([observable$1, __metadata$1(\"design:type\", Array)], TreeModel.prototype, \"roots\", void 0);\n\n__decorate$1([observable$1, __metadata$1(\"design:type\", Object)], TreeModel.prototype, \"expandedNodeIds\", void 0);\n\n__decorate$1([observable$1, __metadata$1(\"design:type\", Object)], TreeModel.prototype, \"selectedLeafNodeIds\", void 0);\n\n__decorate$1([observable$1, __metadata$1(\"design:type\", Object)], TreeModel.prototype, \"activeNodeIds\", void 0);\n\n__decorate$1([observable$1, __metadata$1(\"design:type\", Object)], TreeModel.prototype, \"hiddenNodeIds\", void 0);\n\n__decorate$1([observable$1, __metadata$1(\"design:type\", Object)], TreeModel.prototype, \"focusedNodeId\", void 0);\n\n__decorate$1([observable$1, __metadata$1(\"design:type\", TreeNode)], TreeModel.prototype, \"virtualRoot\", void 0);\n\n__decorate$1([computed$1, __metadata$1(\"design:type\", Object), __metadata$1(\"design:paramtypes\", [])], TreeModel.prototype, \"focusedNode\", null);\n\n__decorate$1([computed$1, __metadata$1(\"design:type\", Object), __metadata$1(\"design:paramtypes\", [])], TreeModel.prototype, \"expandedNodes\", null);\n\n__decorate$1([computed$1, __metadata$1(\"design:type\", Object), __metadata$1(\"design:paramtypes\", [])], TreeModel.prototype, \"activeNodes\", null);\n\n__decorate$1([computed$1, __metadata$1(\"design:type\", Object), __metadata$1(\"design:paramtypes\", [])], TreeModel.prototype, \"hiddenNodes\", null);\n\n__decorate$1([computed$1, __metadata$1(\"design:type\", Object), __metadata$1(\"design:paramtypes\", [])], TreeModel.prototype, \"selectedLeafNodes\", null);\n\n__decorate$1([action$1, __metadata$1(\"design:type\", Function), __metadata$1(\"design:paramtypes\", [Object]), __metadata$1(\"design:returntype\", void 0)], TreeModel.prototype, \"setData\", null);\n\n__decorate$1([action$1, __metadata$1(\"design:type\", Function), __metadata$1(\"design:paramtypes\", []), __metadata$1(\"design:returntype\", void 0)], TreeModel.prototype, \"update\", null);\n\n__decorate$1([action$1, __metadata$1(\"design:type\", Function), __metadata$1(\"design:paramtypes\", [Object]), __metadata$1(\"design:returntype\", void 0)], TreeModel.prototype, \"setFocusedNode\", null);\n\n__decorate$1([action$1, __metadata$1(\"design:type\", Function), __metadata$1(\"design:paramtypes\", [Object]), __metadata$1(\"design:returntype\", void 0)], TreeModel.prototype, \"setFocus\", null);\n\n__decorate$1([action$1, __metadata$1(\"design:type\", Function), __metadata$1(\"design:paramtypes\", [Object]), __metadata$1(\"design:returntype\", void 0)], TreeModel.prototype, \"doForAll\", null);\n\n__decorate$1([action$1, __metadata$1(\"design:type\", Function), __metadata$1(\"design:paramtypes\", []), __metadata$1(\"design:returntype\", void 0)], TreeModel.prototype, \"focusNextNode\", null);\n\n__decorate$1([action$1, __metadata$1(\"design:type\", Function), __metadata$1(\"design:paramtypes\", []), __metadata$1(\"design:returntype\", void 0)], TreeModel.prototype, \"focusPreviousNode\", null);\n\n__decorate$1([action$1, __metadata$1(\"design:type\", Function), __metadata$1(\"design:paramtypes\", []), __metadata$1(\"design:returntype\", void 0)], TreeModel.prototype, \"focusDrillDown\", null);\n\n__decorate$1([action$1, __metadata$1(\"design:type\", Function), __metadata$1(\"design:paramtypes\", []), __metadata$1(\"design:returntype\", void 0)], TreeModel.prototype, \"focusDrillUp\", null);\n\n__decorate$1([action$1, __metadata$1(\"design:type\", Function), __metadata$1(\"design:paramtypes\", [Object, Object, Object]), __metadata$1(\"design:returntype\", void 0)], TreeModel.prototype, \"setActiveNode\", null);\n\n__decorate$1([action$1, __metadata$1(\"design:type\", Function), __metadata$1(\"design:paramtypes\", [Object, Object]), __metadata$1(\"design:returntype\", void 0)], TreeModel.prototype, \"setSelectedNode\", null);\n\n__decorate$1([action$1, __metadata$1(\"design:type\", Function), __metadata$1(\"design:paramtypes\", [Object, Object]), __metadata$1(\"design:returntype\", void 0)], TreeModel.prototype, \"setExpandedNode\", null);\n\n__decorate$1([action$1, __metadata$1(\"design:type\", Function), __metadata$1(\"design:paramtypes\", []), __metadata$1(\"design:returntype\", void 0)], TreeModel.prototype, \"expandAll\", null);\n\n__decorate$1([action$1, __metadata$1(\"design:type\", Function), __metadata$1(\"design:paramtypes\", []), __metadata$1(\"design:returntype\", void 0)], TreeModel.prototype, \"collapseAll\", null);\n\n__decorate$1([action$1, __metadata$1(\"design:type\", Function), __metadata$1(\"design:paramtypes\", [Object, Object]), __metadata$1(\"design:returntype\", void 0)], TreeModel.prototype, \"setIsHidden\", null);\n\n__decorate$1([action$1, __metadata$1(\"design:type\", Function), __metadata$1(\"design:paramtypes\", [Object]), __metadata$1(\"design:returntype\", void 0)], TreeModel.prototype, \"setHiddenNodeIds\", null);\n\n__decorate$1([action$1, __metadata$1(\"design:type\", Function), __metadata$1(\"design:paramtypes\", [Object, Object]), __metadata$1(\"design:returntype\", void 0)], TreeModel.prototype, \"filterNodes\", null);\n\n__decorate$1([action$1, __metadata$1(\"design:type\", Function), __metadata$1(\"design:paramtypes\", []), __metadata$1(\"design:returntype\", void 0)], TreeModel.prototype, \"clearFilter\", null);\n\n__decorate$1([action$1, __metadata$1(\"design:type\", Function), __metadata$1(\"design:paramtypes\", [Object, Object]), __metadata$1(\"design:returntype\", void 0)], TreeModel.prototype, \"moveNode\", null);\n\n__decorate$1([action$1, __metadata$1(\"design:type\", Function), __metadata$1(\"design:paramtypes\", [Object, Object]), __metadata$1(\"design:returntype\", void 0)], TreeModel.prototype, \"copyNode\", null);\n\n__decorate$1([action$1, __metadata$1(\"design:type\", Function), __metadata$1(\"design:paramtypes\", [Object]), __metadata$1(\"design:returntype\", void 0)], TreeModel.prototype, \"setState\", null);\n\nlet TreeDraggedElement = /*#__PURE__*/(() => {\n  class TreeDraggedElement {\n    constructor() {\n      this._draggedElement = null;\n    }\n\n    set(draggedElement) {\n      this._draggedElement = draggedElement;\n    }\n\n    get() {\n      return this._draggedElement;\n    }\n\n    isDragging() {\n      return !!this.get();\n    }\n\n  }\n\n  TreeDraggedElement.ɵfac = function TreeDraggedElement_Factory(t) {\n    return new (t || TreeDraggedElement)();\n  };\n  /** @nocollapse */\n\n\n  TreeDraggedElement.ɵprov = ɵɵdefineInjectable({\n    factory: function TreeDraggedElement_Factory() {\n      return new TreeDraggedElement();\n    },\n    token: TreeDraggedElement,\n    providedIn: \"root\"\n  });\n  return TreeDraggedElement;\n})();\n\nvar __decorate$2 = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nvar __metadata$2 = this && this.__metadata || function (k, v) {\n  if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\n\nconst Y_OFFSET = 500; // Extra pixels outside the viewport, in each direction, to render nodes in\n\nconst Y_EPSILON = 150; // Minimum pixel change required to recalculate the rendered nodes\n\nlet TreeVirtualScroll = /*#__PURE__*/(() => {\n  class TreeVirtualScroll {\n    constructor(treeModel) {\n      this.treeModel = treeModel;\n      this.yBlocks = 0;\n      this.x = 0;\n      this.viewportHeight = null;\n      this.viewport = null;\n      treeModel.virtualScroll = this;\n      this._dispose = [autorun(() => this.fixScroll())];\n    }\n\n    get y() {\n      return this.yBlocks * Y_EPSILON;\n    }\n\n    get totalHeight() {\n      return this.treeModel.virtualRoot ? this.treeModel.virtualRoot.height : 0;\n    }\n\n    fireEvent(event) {\n      this.treeModel.fireEvent(event);\n    }\n\n    init() {\n      const fn = this.recalcPositions.bind(this);\n      fn();\n      this._dispose = [...this._dispose, reaction(() => this.treeModel.roots, fn), reaction(() => this.treeModel.expandedNodeIds, fn), reaction(() => this.treeModel.hiddenNodeIds, fn)];\n      this.treeModel.subscribe(TREE_EVENTS.loadNodeChildren, fn);\n    }\n\n    isEnabled() {\n      return this.treeModel.options.useVirtualScroll;\n    }\n\n    _setYBlocks(value) {\n      this.yBlocks = value;\n    }\n\n    recalcPositions() {\n      this.treeModel.virtualRoot.height = this._getPositionAfter(this.treeModel.getVisibleRoots(), 0);\n    }\n\n    _getPositionAfter(nodes, startPos) {\n      let position = startPos;\n      nodes.forEach(node => {\n        node.position = position;\n        position = this._getPositionAfterNode(node, position);\n      });\n      return position;\n    }\n\n    _getPositionAfterNode(node, startPos) {\n      let position = node.getSelfHeight() + startPos;\n\n      if (node.children && node.isExpanded) {\n        // TBD: consider loading component as well\n        position = this._getPositionAfter(node.visibleChildren, position);\n      }\n\n      node.height = position - startPos;\n      return position;\n    }\n\n    clear() {\n      this._dispose.forEach(d => d());\n    }\n\n    setViewport(viewport) {\n      Object.assign(this, {\n        viewport,\n        x: viewport.scrollLeft,\n        yBlocks: Math.round(viewport.scrollTop / Y_EPSILON),\n        viewportHeight: viewport.getBoundingClientRect ? viewport.getBoundingClientRect().height : 0\n      });\n    }\n\n    scrollIntoView(node, force, scrollToMiddle = true) {\n      if (node.options.scrollContainer) {\n        const scrollContainer = node.options.scrollContainer;\n        const scrollContainerHeight = scrollContainer.getBoundingClientRect().height;\n        const scrollContainerTop = scrollContainer.getBoundingClientRect().top;\n        const nodeTop = this.viewport.getBoundingClientRect().top + node.position - scrollContainerTop;\n\n        if (force || // force scroll to node\n        nodeTop < scrollContainer.scrollTop || // node is above scroll container\n        nodeTop + node.getSelfHeight() > scrollContainer.scrollTop + scrollContainerHeight) {\n          // node is below container\n          scrollContainer.scrollTop = scrollToMiddle ? nodeTop - scrollContainerHeight / 2 : // scroll to middle\n          nodeTop; // scroll to start\n        }\n      } else {\n        if (force || // force scroll to node\n        node.position < this.y || // node is above viewport\n        node.position + node.getSelfHeight() > this.y + this.viewportHeight) {\n          // node is below viewport\n          if (this.viewport) {\n            this.viewport.scrollTop = scrollToMiddle ? node.position - this.viewportHeight / 2 : // scroll to middle\n            node.position; // scroll to start\n\n            this._setYBlocks(Math.floor(this.viewport.scrollTop / Y_EPSILON));\n          }\n        }\n      }\n    }\n\n    getViewportNodes(nodes) {\n      if (!nodes) return [];\n      const visibleNodes = nodes.filter(node => !node.isHidden);\n      if (!this.isEnabled()) return visibleNodes;\n      if (!this.viewportHeight || !visibleNodes.length) return []; // When loading children async this method is called before their height and position is calculated.\n      // In that case firstIndex === 0 and lastIndex === visibleNodes.length - 1 (e.g. 1000),\n      // which means that it loops through every visibleNodes item and push them into viewportNodes array.\n      // We can prevent nodes from being pushed to the array and wait for the appropriate calculations to take place\n\n      const lastVisibleNode = visibleNodes.slice(-1)[0];\n      if (!lastVisibleNode.height && lastVisibleNode.position === 0) return []; // Search for first node in the viewport using binary search\n      // Look for first node that starts after the beginning of the viewport (with buffer)\n      // Or that ends after the beginning of the viewport\n\n      const firstIndex = binarySearch(visibleNodes, node => {\n        return node.position + Y_OFFSET > this.y || node.position + node.height > this.y;\n      }); // Search for last node in the viewport using binary search\n      // Look for first node that starts after the end of the viewport (with buffer)\n\n      const lastIndex = binarySearch(visibleNodes, node => {\n        return node.position - Y_OFFSET > this.y + this.viewportHeight;\n      }, firstIndex);\n      const viewportNodes = [];\n\n      for (let i = firstIndex; i <= lastIndex; i++) {\n        viewportNodes.push(visibleNodes[i]);\n      }\n\n      return viewportNodes;\n    }\n\n    fixScroll() {\n      const maxY = Math.max(0, this.totalHeight - this.viewportHeight);\n      if (this.y < 0) this._setYBlocks(0);\n      if (this.y > maxY) this._setYBlocks(maxY / Y_EPSILON);\n    }\n\n  }\n\n  TreeVirtualScroll.ɵfac = function TreeVirtualScroll_Factory(t) {\n    return new (t || TreeVirtualScroll)(ɵngcc0.ɵɵinject(TreeModel));\n  };\n\n  TreeVirtualScroll.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: TreeVirtualScroll,\n    factory: TreeVirtualScroll.ɵfac\n  });\n  /** @nocollapse */\n\n  return TreeVirtualScroll;\n})();\n\n__decorate$2([observable$1, __metadata$2(\"design:type\", Object)], TreeVirtualScroll.prototype, \"yBlocks\", void 0);\n\n__decorate$2([observable$1, __metadata$2(\"design:type\", Object)], TreeVirtualScroll.prototype, \"x\", void 0);\n\n__decorate$2([observable$1, __metadata$2(\"design:type\", Object)], TreeVirtualScroll.prototype, \"viewportHeight\", void 0);\n\n__decorate$2([computed$1, __metadata$2(\"design:type\", Object), __metadata$2(\"design:paramtypes\", [])], TreeVirtualScroll.prototype, \"y\", null);\n\n__decorate$2([computed$1, __metadata$2(\"design:type\", Object), __metadata$2(\"design:paramtypes\", [])], TreeVirtualScroll.prototype, \"totalHeight\", null);\n\n__decorate$2([action$1, __metadata$2(\"design:type\", Function), __metadata$2(\"design:paramtypes\", [Object]), __metadata$2(\"design:returntype\", void 0)], TreeVirtualScroll.prototype, \"_setYBlocks\", null);\n\n__decorate$2([action$1, __metadata$2(\"design:type\", Function), __metadata$2(\"design:paramtypes\", []), __metadata$2(\"design:returntype\", void 0)], TreeVirtualScroll.prototype, \"recalcPositions\", null);\n\n__decorate$2([action$1, __metadata$2(\"design:type\", Function), __metadata$2(\"design:paramtypes\", [Object]), __metadata$2(\"design:returntype\", void 0)], TreeVirtualScroll.prototype, \"setViewport\", null);\n\n__decorate$2([action$1, __metadata$2(\"design:type\", Function), __metadata$2(\"design:paramtypes\", [Object, Object, Object]), __metadata$2(\"design:returntype\", void 0)], TreeVirtualScroll.prototype, \"scrollIntoView\", null);\n\nfunction binarySearch(nodes, condition, firstIndex = 0) {\n  let index = firstIndex;\n  let toIndex = nodes.length - 1;\n\n  while (index !== toIndex) {\n    let midIndex = Math.floor((index + toIndex) / 2);\n\n    if (condition(nodes[midIndex])) {\n      toIndex = midIndex;\n    } else {\n      if (index === midIndex) index = toIndex;else index = midIndex;\n    }\n  }\n\n  return index;\n}\n\nlet LoadingComponent = /*#__PURE__*/(() => {\n  class LoadingComponent {}\n\n  LoadingComponent.ɵfac = function LoadingComponent_Factory(t) {\n    return new (t || LoadingComponent)();\n  };\n\n  LoadingComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: LoadingComponent,\n    selectors: [[\"tree-loading-component\"]],\n    inputs: {\n      template: \"template\",\n      node: \"node\"\n    },\n    decls: 2,\n    vars: 5,\n    consts: [[4, \"ngIf\"], [3, \"ngTemplateOutlet\", \"ngTemplateOutletContext\"]],\n    template: function LoadingComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵtemplate(0, LoadingComponent_span_0_Template, 2, 0, \"span\", 0);\n        ɵngcc0.ɵɵelementContainer(1, 1);\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵproperty(\"ngIf\", !ctx.template);\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngTemplateOutlet\", ctx.template)(\"ngTemplateOutletContext\", ɵngcc0.ɵɵpureFunction1(3, _c0, ctx.node));\n      }\n    },\n    directives: [ɵngcc1.NgIf, ɵngcc1.NgTemplateOutlet],\n    encapsulation: 2\n  });\n  return LoadingComponent;\n})();\nlet TreeViewportComponent = /*#__PURE__*/(() => {\n  class TreeViewportComponent {\n    constructor(elementRef, virtualScroll) {\n      this.elementRef = elementRef;\n      this.virtualScroll = virtualScroll;\n      this.setViewport = this.throttle(() => {\n        this.virtualScroll.setViewport(this.elementRef.nativeElement);\n      }, 17);\n      this.scrollEventHandler = this.setViewport.bind(this);\n    }\n\n    ngOnInit() {\n      this.virtualScroll.init();\n    }\n\n    ngAfterViewInit() {\n      setTimeout(() => {\n        this.setViewport();\n        this.virtualScroll.fireEvent({\n          eventName: TREE_EVENTS.initialized\n        });\n      });\n      let el = this.elementRef.nativeElement;\n      el.addEventListener('scroll', this.scrollEventHandler);\n    }\n\n    ngOnDestroy() {\n      this.virtualScroll.clear();\n      let el = this.elementRef.nativeElement;\n      el.removeEventListener('scroll', this.scrollEventHandler);\n    }\n\n    getTotalHeight() {\n      return this.virtualScroll.isEnabled() && this.virtualScroll.totalHeight + 'px' || 'auto';\n    }\n\n    throttle(func, timeFrame) {\n      let lastTime = 0;\n      return function () {\n        let now = Date.now();\n\n        if (now - lastTime >= timeFrame) {\n          func();\n          lastTime = now;\n        }\n      };\n    }\n\n  }\n\n  TreeViewportComponent.ɵfac = function TreeViewportComponent_Factory(t) {\n    return new (t || TreeViewportComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(TreeVirtualScroll));\n  };\n\n  TreeViewportComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: TreeViewportComponent,\n    selectors: [[\"tree-viewport\"]],\n    features: [ɵngcc0.ɵɵProvidersFeature([TreeVirtualScroll])],\n    ngContentSelectors: _c2,\n    decls: 1,\n    vars: 2,\n    consts: [[4, \"treeMobxAutorun\"]],\n    template: function TreeViewportComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵtemplate(0, TreeViewportComponent_ng_container_0_Template, 3, 2, \"ng-container\", 0);\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵproperty(\"treeMobxAutorun\", ɵngcc0.ɵɵpureFunction0(1, _c1));\n      }\n    },\n    directives: [TreeMobxAutorunDirective],\n    encapsulation: 2\n  });\n  /** @nocollapse */\n\n  return TreeViewportComponent;\n})();\nlet TreeComponent = /*#__PURE__*/(() => {\n  class TreeComponent {\n    constructor(treeModel, treeDraggedElement) {\n      this.treeModel = treeModel;\n      this.treeDraggedElement = treeDraggedElement;\n      treeModel.eventNames.forEach(name => this[name] = new EventEmitter());\n      treeModel.subscribeToState(state => this.stateChange.emit(state));\n    } // Will be handled in ngOnChanges\n\n\n    set nodes(nodes) {}\n\n    set options(options) {}\n\n    set focused(value) {\n      this.treeModel.setFocus(value);\n    }\n\n    set state(state) {\n      this.treeModel.setState(state);\n    }\n\n    onKeydown($event) {\n      if (!this.treeModel.isFocused) return;\n      if (['input', 'textarea'].includes(document.activeElement.tagName.toLowerCase())) return;\n      const focusedNode = this.treeModel.getFocusedNode();\n      this.treeModel.performKeyAction(focusedNode, $event);\n    }\n\n    onMousedown($event) {\n      function isOutsideClick(startElement, nodeName) {\n        return !startElement ? true : startElement.localName === nodeName ? false : isOutsideClick(startElement.parentElement, nodeName);\n      }\n\n      if (isOutsideClick($event.target, 'tree-root')) {\n        this.treeModel.setFocus(false);\n      }\n    }\n\n    ngOnChanges(changes) {\n      if (changes.options || changes.nodes) {\n        this.treeModel.setData({\n          options: changes.options && changes.options.currentValue,\n          nodes: changes.nodes && changes.nodes.currentValue,\n          events: this.pick(this, this.treeModel.eventNames)\n        });\n      }\n    }\n\n    sizeChanged() {\n      this.viewportComponent.setViewport();\n    }\n\n    pick(object, keys) {\n      return keys.reduce((obj, key) => {\n        if (object && object.hasOwnProperty(key)) {\n          obj[key] = object[key];\n        }\n\n        return obj;\n      }, {});\n    }\n\n  }\n\n  TreeComponent.ɵfac = function TreeComponent_Factory(t) {\n    return new (t || TreeComponent)(ɵngcc0.ɵɵdirectiveInject(TreeModel), ɵngcc0.ɵɵdirectiveInject(TreeDraggedElement));\n  };\n\n  TreeComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: TreeComponent,\n    selectors: [[\"Tree\"], [\"tree-root\"]],\n    contentQueries: function TreeComponent_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵcontentQuery(dirIndex, _c3, 5);\n        ɵngcc0.ɵɵcontentQuery(dirIndex, _c4, 5);\n        ɵngcc0.ɵɵcontentQuery(dirIndex, _c5, 5);\n        ɵngcc0.ɵɵcontentQuery(dirIndex, _c6, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.loadingTemplate = _t.first);\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.treeNodeTemplate = _t.first);\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.treeNodeWrapperTemplate = _t.first);\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.treeNodeFullTemplate = _t.first);\n      }\n    },\n    viewQuery: function TreeComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵviewQuery(_c7, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.viewportComponent = _t.first);\n      }\n    },\n    hostBindings: function TreeComponent_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵlistener(\"keydown\", function TreeComponent_keydown_HostBindingHandler($event) {\n          return ctx.onKeydown($event);\n        }, false, ɵngcc0.ɵɵresolveBody)(\"mousedown\", function TreeComponent_mousedown_HostBindingHandler($event) {\n          return ctx.onMousedown($event);\n        }, false, ɵngcc0.ɵɵresolveBody);\n      }\n    },\n    inputs: {\n      nodes: \"nodes\",\n      options: \"options\",\n      focused: \"focused\",\n      state: \"state\"\n    },\n    outputs: {\n      toggleExpanded: \"toggleExpanded\",\n      activate: \"activate\",\n      deactivate: \"deactivate\",\n      nodeActivate: \"nodeActivate\",\n      nodeDeactivate: \"nodeDeactivate\",\n      select: \"select\",\n      deselect: \"deselect\",\n      focus: \"focus\",\n      blur: \"blur\",\n      updateData: \"updateData\",\n      initialized: \"initialized\",\n      moveNode: \"moveNode\",\n      copyNode: \"copyNode\",\n      loadNodeChildren: \"loadNodeChildren\",\n      changeFilter: \"changeFilter\",\n      event: \"event\",\n      stateChange: \"stateChange\"\n    },\n    features: [ɵngcc0.ɵɵProvidersFeature([TreeModel]), ɵngcc0.ɵɵNgOnChangesFeature],\n    decls: 5,\n    vars: 6,\n    consts: [[\"viewport\", \"\"], [1, \"angular-tree-component\"], [3, \"nodes\", \"treeModel\", \"templates\", 4, \"ngIf\"], [\"class\", \"empty-tree-drop-slot\", 3, \"dropIndex\", \"node\", 4, \"ngIf\"], [3, \"nodes\", \"treeModel\", \"templates\"], [1, \"empty-tree-drop-slot\", 3, \"dropIndex\", \"node\"]],\n    template: function TreeComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵelementStart(0, \"tree-viewport\", null, 0);\n        ɵngcc0.ɵɵelementStart(2, \"div\", 1);\n        ɵngcc0.ɵɵtemplate(3, TreeComponent_tree_node_collection_3_Template, 1, 8, \"tree-node-collection\", 2);\n        ɵngcc0.ɵɵtemplate(4, TreeComponent_tree_node_drop_slot_4_Template, 1, 2, \"tree-node-drop-slot\", 3);\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵadvance(2);\n        ɵngcc0.ɵɵclassProp(\"node-dragging\", ctx.treeDraggedElement.isDragging())(\"angular-tree-component-rtl\", ctx.treeModel.options.rtl);\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngIf\", ctx.treeModel.roots);\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngIf\", ctx.treeModel.isEmptyTree());\n      }\n    },\n    directives: function () {\n      return [TreeViewportComponent, ɵngcc1.NgIf, TreeNodeCollectionComponent, TreeNodeDropSlot];\n    },\n    encapsulation: 2\n  });\n  /** @nocollapse */\n\n  return TreeComponent;\n})();\nlet TreeNodeComponent = /*#__PURE__*/(() => {\n  class TreeNodeComponent {}\n\n  TreeNodeComponent.ɵfac = function TreeNodeComponent_Factory(t) {\n    return new (t || TreeNodeComponent)();\n  };\n\n  TreeNodeComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: TreeNodeComponent,\n    selectors: [[\"TreeNode\"], [\"tree-node\"]],\n    inputs: {\n      node: \"node\",\n      index: \"index\",\n      templates: \"templates\"\n    },\n    decls: 1,\n    vars: 2,\n    consts: [[4, \"treeMobxAutorun\"], [3, \"class\", \"tree-node\", \"tree-node-expanded\", \"tree-node-collapsed\", \"tree-node-leaf\", \"tree-node-active\", \"tree-node-focused\", 4, \"ngIf\"], [3, \"ngTemplateOutlet\", \"ngTemplateOutletContext\"], [3, \"dropIndex\", \"node\", 4, \"ngIf\"], [3, \"node\", \"index\", \"templates\"], [3, \"node\", \"templates\"], [3, \"dropIndex\", \"node\"]],\n    template: function TreeNodeComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵtemplate(0, TreeNodeComponent_ng_container_0_Template, 3, 8, \"ng-container\", 0);\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵproperty(\"treeMobxAutorun\", ɵngcc0.ɵɵpureFunction0(1, _c1));\n      }\n    },\n    directives: function () {\n      return [TreeMobxAutorunDirective, ɵngcc1.NgIf, ɵngcc1.NgTemplateOutlet, TreeNodeWrapperComponent, TreeNodeChildrenComponent, TreeNodeDropSlot];\n    },\n    encapsulation: 2\n  });\n  return TreeNodeComponent;\n})();\nlet TreeNodeContent = /*#__PURE__*/(() => {\n  class TreeNodeContent {}\n\n  TreeNodeContent.ɵfac = function TreeNodeContent_Factory(t) {\n    return new (t || TreeNodeContent)();\n  };\n\n  TreeNodeContent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: TreeNodeContent,\n    selectors: [[\"tree-node-content\"]],\n    inputs: {\n      node: \"node\",\n      index: \"index\",\n      template: \"template\"\n    },\n    decls: 2,\n    vars: 7,\n    consts: [[4, \"ngIf\"], [3, \"ngTemplateOutlet\", \"ngTemplateOutletContext\"]],\n    template: function TreeNodeContent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵtemplate(0, TreeNodeContent_span_0_Template, 2, 1, \"span\", 0);\n        ɵngcc0.ɵɵelementContainer(1, 1);\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵproperty(\"ngIf\", !ctx.template);\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngTemplateOutlet\", ctx.template)(\"ngTemplateOutletContext\", ɵngcc0.ɵɵpureFunction3(3, _c10, ctx.node, ctx.node, ctx.index));\n      }\n    },\n    directives: [ɵngcc1.NgIf, ɵngcc1.NgTemplateOutlet],\n    encapsulation: 2\n  });\n  return TreeNodeContent;\n})();\nlet TreeNodeDropSlot = /*#__PURE__*/(() => {\n  class TreeNodeDropSlot {\n    onDrop($event) {\n      this.node.mouseAction('drop', $event.event, {\n        from: $event.element,\n        to: {\n          parent: this.node,\n          index: this.dropIndex\n        }\n      });\n    }\n\n    allowDrop(element, $event) {\n      return this.node.options.allowDrop(element, {\n        parent: this.node,\n        index: this.dropIndex\n      }, $event);\n    }\n\n  }\n\n  TreeNodeDropSlot.ɵfac = function TreeNodeDropSlot_Factory(t) {\n    return new (t || TreeNodeDropSlot)();\n  };\n\n  TreeNodeDropSlot.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: TreeNodeDropSlot,\n    selectors: [[\"TreeNodeDropSlot\"], [\"tree-node-drop-slot\"]],\n    inputs: {\n      node: \"node\",\n      dropIndex: \"dropIndex\"\n    },\n    decls: 1,\n    vars: 2,\n    consts: [[1, \"node-drop-slot\", 3, \"treeAllowDrop\", \"allowDragoverStyling\", \"treeDrop\"]],\n    template: function TreeNodeDropSlot_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵelementStart(0, \"div\", 0);\n        ɵngcc0.ɵɵlistener(\"treeDrop\", function TreeNodeDropSlot_Template_div_treeDrop_0_listener($event) {\n          return ctx.onDrop($event);\n        });\n        ɵngcc0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵproperty(\"treeAllowDrop\", ctx.allowDrop.bind(ctx))(\"allowDragoverStyling\", true);\n      }\n    },\n    directives: function () {\n      return [TreeDropDirective];\n    },\n    encapsulation: 2\n  });\n  return TreeNodeDropSlot;\n})();\nlet TreeNodeExpanderComponent = /*#__PURE__*/(() => {\n  class TreeNodeExpanderComponent {}\n\n  TreeNodeExpanderComponent.ɵfac = function TreeNodeExpanderComponent_Factory(t) {\n    return new (t || TreeNodeExpanderComponent)();\n  };\n\n  TreeNodeExpanderComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: TreeNodeExpanderComponent,\n    selectors: [[\"tree-node-expander\"]],\n    inputs: {\n      node: \"node\"\n    },\n    decls: 1,\n    vars: 2,\n    consts: [[4, \"treeMobxAutorun\"], [\"class\", \"toggle-children-wrapper\", 3, \"toggle-children-wrapper-expanded\", \"toggle-children-wrapper-collapsed\", \"click\", 4, \"ngIf\"], [\"class\", \"toggle-children-placeholder\", 4, \"ngIf\"], [1, \"toggle-children-wrapper\", 3, \"click\"], [1, \"toggle-children\"], [1, \"toggle-children-placeholder\"]],\n    template: function TreeNodeExpanderComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵtemplate(0, TreeNodeExpanderComponent_ng_container_0_Template, 3, 2, \"ng-container\", 0);\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵproperty(\"treeMobxAutorun\", ɵngcc0.ɵɵpureFunction0(1, _c1));\n      }\n    },\n    directives: [TreeMobxAutorunDirective, ɵngcc1.NgIf],\n    encapsulation: 2\n  });\n  return TreeNodeExpanderComponent;\n})();\nlet TreeNodeChildrenComponent = /*#__PURE__*/(() => {\n  class TreeNodeChildrenComponent {}\n\n  TreeNodeChildrenComponent.ɵfac = function TreeNodeChildrenComponent_Factory(t) {\n    return new (t || TreeNodeChildrenComponent)();\n  };\n\n  TreeNodeChildrenComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: TreeNodeChildrenComponent,\n    selectors: [[\"tree-node-children\"]],\n    inputs: {\n      node: \"node\",\n      templates: \"templates\"\n    },\n    decls: 1,\n    vars: 2,\n    consts: [[4, \"treeMobxAutorun\"], [3, \"tree-children\", \"tree-children-no-padding\", 4, \"treeAnimateOpen\", \"treeAnimateOpenSpeed\", \"treeAnimateOpenAcceleration\", \"treeAnimateOpenEnabled\"], [3, \"nodes\", \"templates\", \"treeModel\", 4, \"ngIf\"], [\"class\", \"tree-node-loading\", 3, \"padding-left\", \"template\", \"node\", 4, \"ngIf\"], [3, \"nodes\", \"templates\", \"treeModel\"], [1, \"tree-node-loading\", 3, \"template\", \"node\"]],\n    template: function TreeNodeChildrenComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵtemplate(0, TreeNodeChildrenComponent_ng_container_0_Template, 2, 4, \"ng-container\", 0);\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵproperty(\"treeMobxAutorun\", ɵngcc0.ɵɵpureFunction0(1, _c1));\n      }\n    },\n    directives: function () {\n      return [TreeMobxAutorunDirective, TreeAnimateOpenDirective, ɵngcc1.NgIf, TreeNodeCollectionComponent, LoadingComponent];\n    },\n    encapsulation: 2\n  });\n  return TreeNodeChildrenComponent;\n})();\n\n// Re-export mobx operators to be able to use inside components with AOT:\nfunction actionInternal(...args) {\n  return action$1(...args);\n}\n\nconst action = Object.assign(actionInternal, action$1);\n\nfunction computedInternal(...args) {\n  return computed$1(...args);\n}\n\nconst computed = Object.assign(computedInternal, computed$1);\n\nfunction observableInternal(...args) {\n  return observable$1(...args);\n}\n\nconst observable = Object.assign(observableInternal, observable$1);\n\nvar __decorate$3 = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nvar __metadata$3 = this && this.__metadata || function (k, v) {\n  if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\n\nlet TreeNodeCollectionComponent = /*#__PURE__*/(() => {\n  class TreeNodeCollectionComponent {\n    constructor() {\n      this._dispose = [];\n    }\n\n    get nodes() {\n      return this._nodes;\n    }\n\n    set nodes(nodes) {\n      this.setNodes(nodes);\n    }\n\n    get marginTop() {\n      const firstNode = this.viewportNodes && this.viewportNodes.length && this.viewportNodes[0];\n      const relativePosition = firstNode && firstNode.parent ? firstNode.position - firstNode.parent.position - firstNode.parent.getSelfHeight() : 0;\n      return `${relativePosition}px`;\n    }\n\n    setNodes(nodes) {\n      this._nodes = nodes;\n    }\n\n    ngOnInit() {\n      this.virtualScroll = this.treeModel.virtualScroll;\n      this._dispose = [// return node indexes so we can compare structurally,\n      reaction(() => {\n        return this.virtualScroll.getViewportNodes(this.nodes).map(n => n.index);\n      }, nodeIndexes => {\n        this.viewportNodes = nodeIndexes.map(i => this.nodes[i]);\n      }, {\n        compareStructural: true,\n        fireImmediately: true\n      }), reaction(() => this.nodes, nodes => {\n        this.viewportNodes = this.virtualScroll.getViewportNodes(nodes);\n      })];\n    }\n\n    ngOnDestroy() {\n      this._dispose.forEach(d => d());\n    }\n\n    trackNode(index, node) {\n      return node.id;\n    }\n\n  }\n\n  TreeNodeCollectionComponent.ɵfac = function TreeNodeCollectionComponent_Factory(t) {\n    return new (t || TreeNodeCollectionComponent)();\n  };\n\n  TreeNodeCollectionComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: TreeNodeCollectionComponent,\n    selectors: [[\"tree-node-collection\"]],\n    inputs: {\n      nodes: \"nodes\",\n      treeModel: \"treeModel\",\n      templates: \"templates\"\n    },\n    decls: 1,\n    vars: 2,\n    consts: [[4, \"treeMobxAutorun\"], [3, \"node\", \"index\", \"templates\", 4, \"ngFor\", \"ngForOf\", \"ngForTrackBy\"], [3, \"node\", \"index\", \"templates\"]],\n    template: function TreeNodeCollectionComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵtemplate(0, TreeNodeCollectionComponent_ng_container_0_Template, 3, 4, \"ng-container\", 0);\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵproperty(\"treeMobxAutorun\", ɵngcc0.ɵɵpureFunction0(1, _c1));\n      }\n    },\n    directives: [TreeMobxAutorunDirective, ɵngcc1.NgForOf, TreeNodeComponent],\n    encapsulation: 2\n  });\n  return TreeNodeCollectionComponent;\n})();\n\n__decorate$3([observable, __metadata$3(\"design:type\", Object)], TreeNodeCollectionComponent.prototype, \"_nodes\", void 0);\n\n__decorate$3([observable, __metadata$3(\"design:type\", Array)], TreeNodeCollectionComponent.prototype, \"viewportNodes\", void 0);\n\n__decorate$3([computed, __metadata$3(\"design:type\", String), __metadata$3(\"design:paramtypes\", [])], TreeNodeCollectionComponent.prototype, \"marginTop\", null);\n\n__decorate$3([action, __metadata$3(\"design:type\", Function), __metadata$3(\"design:paramtypes\", [Object]), __metadata$3(\"design:returntype\", void 0)], TreeNodeCollectionComponent.prototype, \"setNodes\", null);\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet TreeNodeWrapperComponent = /*#__PURE__*/(() => {\n  class TreeNodeWrapperComponent {}\n\n  TreeNodeWrapperComponent.ɵfac = function TreeNodeWrapperComponent_Factory(t) {\n    return new (t || TreeNodeWrapperComponent)();\n  };\n\n  TreeNodeWrapperComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: TreeNodeWrapperComponent,\n    selectors: [[\"tree-node-wrapper\"]],\n    inputs: {\n      node: \"node\",\n      index: \"index\",\n      templates: \"templates\"\n    },\n    decls: 2,\n    vars: 8,\n    consts: [[\"class\", \"node-wrapper\", 3, \"padding-left\", 4, \"ngIf\"], [3, \"ngTemplateOutlet\", \"ngTemplateOutletContext\"], [1, \"node-wrapper\"], [3, \"node\", 4, \"ngIf\"], [3, \"node\"], [1, \"node-content-wrapper\", 3, \"treeAllowDrop\", \"allowDragoverStyling\", \"treeDrag\", \"treeDragEnabled\", \"click\", \"dblclick\", \"mouseover\", \"mouseout\", \"contextmenu\", \"treeDrop\", \"treeDropDragOver\", \"treeDropDragLeave\", \"treeDropDragEnter\"], [3, \"node\", \"index\", \"template\"]],\n    template: function TreeNodeWrapperComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵtemplate(0, TreeNodeWrapperComponent_div_0_Template, 5, 15, \"div\", 0);\n        ɵngcc0.ɵɵelementContainer(1, 1);\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵproperty(\"ngIf\", !ctx.templates.treeNodeWrapperTemplate);\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngTemplateOutlet\", ctx.templates.treeNodeWrapperTemplate)(\"ngTemplateOutletContext\", ɵngcc0.ɵɵpureFunction4(3, _c9, ctx.node, ctx.node, ctx.index, ctx.templates));\n      }\n    },\n    directives: function () {\n      return [ɵngcc1.NgIf, ɵngcc1.NgTemplateOutlet, TreeNodeExpanderComponent, TreeDragDirective, TreeDropDirective, TreeNodeContent, TreeNodeCheckboxComponent];\n    },\n    encapsulation: 2\n  });\n  return TreeNodeWrapperComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet TreeNodeCheckboxComponent = /*#__PURE__*/(() => {\n  class TreeNodeCheckboxComponent {}\n\n  TreeNodeCheckboxComponent.ɵfac = function TreeNodeCheckboxComponent_Factory(t) {\n    return new (t || TreeNodeCheckboxComponent)();\n  };\n\n  TreeNodeCheckboxComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: TreeNodeCheckboxComponent,\n    selectors: [[\"tree-node-checkbox\"]],\n    inputs: {\n      node: \"node\"\n    },\n    decls: 1,\n    vars: 2,\n    consts: [[4, \"treeMobxAutorun\"], [\"type\", \"checkbox\", 1, \"tree-node-checkbox\", 3, \"checked\", \"indeterminate\", \"click\"]],\n    template: function TreeNodeCheckboxComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵtemplate(0, TreeNodeCheckboxComponent_ng_container_0_Template, 2, 2, \"ng-container\", 0);\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵproperty(\"treeMobxAutorun\", ɵngcc0.ɵɵpureFunction0(1, _c1));\n      }\n    },\n    directives: [TreeMobxAutorunDirective],\n    encapsulation: 2\n  });\n  return TreeNodeCheckboxComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst DRAG_OVER_CLASS = 'is-dragging-over';\nconst DRAG_DISABLED_CLASS = 'is-dragging-over-disabled';\nlet TreeDropDirective = /*#__PURE__*/(() => {\n  class TreeDropDirective {\n    constructor(el, renderer, treeDraggedElement, ngZone) {\n      this.el = el;\n      this.renderer = renderer;\n      this.treeDraggedElement = treeDraggedElement;\n      this.ngZone = ngZone;\n      this.allowDragoverStyling = true;\n      this.onDropCallback = new EventEmitter();\n      this.onDragOverCallback = new EventEmitter();\n      this.onDragLeaveCallback = new EventEmitter();\n      this.onDragEnterCallback = new EventEmitter();\n\n      this._allowDrop = (element, $event) => true;\n\n      this.dragOverEventHandler = this.onDragOver.bind(this);\n      this.dragEnterEventHandler = this.onDragEnter.bind(this);\n      this.dragLeaveEventHandler = this.onDragLeave.bind(this);\n    }\n\n    set treeAllowDrop(allowDrop) {\n      if (allowDrop instanceof Function) {\n        this._allowDrop = allowDrop;\n      } else this._allowDrop = (element, $event) => allowDrop;\n    }\n\n    allowDrop($event) {\n      return this._allowDrop(this.treeDraggedElement.get(), $event);\n    }\n\n    ngAfterViewInit() {\n      let el = this.el.nativeElement;\n      this.ngZone.runOutsideAngular(() => {\n        el.addEventListener('dragover', this.dragOverEventHandler);\n        el.addEventListener('dragenter', this.dragEnterEventHandler);\n        el.addEventListener('dragleave', this.dragLeaveEventHandler);\n      });\n    }\n\n    ngOnDestroy() {\n      let el = this.el.nativeElement;\n      el.removeEventListener('dragover', this.dragOverEventHandler);\n      el.removeEventListener('dragenter', this.dragEnterEventHandler);\n      el.removeEventListener('dragleave', this.dragLeaveEventHandler);\n    }\n\n    onDragOver($event) {\n      if (!this.allowDrop($event)) {\n        if (this.allowDragoverStyling) {\n          return this.addDisabledClass();\n        }\n\n        return;\n      }\n\n      this.onDragOverCallback.emit({\n        event: $event,\n        element: this.treeDraggedElement.get()\n      });\n      $event.preventDefault();\n\n      if (this.allowDragoverStyling) {\n        this.addClass();\n      }\n    }\n\n    onDragEnter($event) {\n      if (!this.allowDrop($event)) return;\n      $event.preventDefault();\n      this.onDragEnterCallback.emit({\n        event: $event,\n        element: this.treeDraggedElement.get()\n      });\n    }\n\n    onDragLeave($event) {\n      if (!this.allowDrop($event)) {\n        if (this.allowDragoverStyling) {\n          return this.removeDisabledClass();\n        }\n\n        return;\n      }\n\n      this.onDragLeaveCallback.emit({\n        event: $event,\n        element: this.treeDraggedElement.get()\n      });\n\n      if (this.allowDragoverStyling) {\n        this.removeClass();\n      }\n    }\n\n    onDrop($event) {\n      if (!this.allowDrop($event)) return;\n      $event.preventDefault();\n      this.onDropCallback.emit({\n        event: $event,\n        element: this.treeDraggedElement.get()\n      });\n\n      if (this.allowDragoverStyling) {\n        this.removeClass();\n      }\n\n      this.treeDraggedElement.set(null);\n    }\n\n    addClass() {\n      this.renderer.addClass(this.el.nativeElement, DRAG_OVER_CLASS);\n    }\n\n    removeClass() {\n      this.renderer.removeClass(this.el.nativeElement, DRAG_OVER_CLASS);\n    }\n\n    addDisabledClass() {\n      this.renderer.addClass(this.el.nativeElement, DRAG_DISABLED_CLASS);\n    }\n\n    removeDisabledClass() {\n      this.renderer.removeClass(this.el.nativeElement, DRAG_DISABLED_CLASS);\n    }\n\n  }\n\n  TreeDropDirective.ɵfac = function TreeDropDirective_Factory(t) {\n    return new (t || TreeDropDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(TreeDraggedElement), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone));\n  };\n\n  TreeDropDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: TreeDropDirective,\n    selectors: [[\"\", \"treeDrop\", \"\"]],\n    hostBindings: function TreeDropDirective_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵlistener(\"drop\", function TreeDropDirective_drop_HostBindingHandler($event) {\n          return ctx.onDrop($event);\n        });\n      }\n    },\n    inputs: {\n      allowDragoverStyling: \"allowDragoverStyling\",\n      treeAllowDrop: \"treeAllowDrop\"\n    },\n    outputs: {\n      onDropCallback: \"treeDrop\",\n      onDragOverCallback: \"treeDropDragOver\",\n      onDragLeaveCallback: \"treeDropDragLeave\",\n      onDragEnterCallback: \"treeDropDragEnter\"\n    }\n  });\n  /** @nocollapse */\n\n  return TreeDropDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst DRAG_OVER_CLASS$1 = 'is-dragging-over';\nlet TreeDragDirective = /*#__PURE__*/(() => {\n  class TreeDragDirective {\n    constructor(el, renderer, treeDraggedElement, ngZone) {\n      this.el = el;\n      this.renderer = renderer;\n      this.treeDraggedElement = treeDraggedElement;\n      this.ngZone = ngZone;\n      this.dragEventHandler = this.onDrag.bind(this);\n    }\n\n    ngAfterViewInit() {\n      let el = this.el.nativeElement;\n      this.ngZone.runOutsideAngular(() => {\n        el.addEventListener('drag', this.dragEventHandler);\n      });\n    }\n\n    ngDoCheck() {\n      this.renderer.setAttribute(this.el.nativeElement, 'draggable', this.treeDragEnabled ? 'true' : 'false');\n    }\n\n    ngOnDestroy() {\n      let el = this.el.nativeElement;\n      el.removeEventListener('drag', this.dragEventHandler);\n    }\n\n    onDragStart(ev) {\n      // setting the data is required by firefox\n      ev.dataTransfer.setData('text', ev.target.id);\n      this.treeDraggedElement.set(this.draggedElement);\n\n      if (this.draggedElement.mouseAction) {\n        this.draggedElement.mouseAction('dragStart', ev);\n      }\n    }\n\n    onDrag(ev) {\n      if (this.draggedElement.mouseAction) {\n        this.draggedElement.mouseAction('drag', ev);\n      }\n    }\n\n    onDragEnd() {\n      if (this.draggedElement.mouseAction) {\n        this.draggedElement.mouseAction('dragEnd');\n      }\n\n      this.treeDraggedElement.set(null);\n    }\n\n  }\n\n  TreeDragDirective.ɵfac = function TreeDragDirective_Factory(t) {\n    return new (t || TreeDragDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(TreeDraggedElement), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone));\n  };\n\n  TreeDragDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: TreeDragDirective,\n    selectors: [[\"\", \"treeDrag\", \"\"]],\n    hostBindings: function TreeDragDirective_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵlistener(\"dragstart\", function TreeDragDirective_dragstart_HostBindingHandler($event) {\n          return ctx.onDragStart($event);\n        })(\"dragend\", function TreeDragDirective_dragend_HostBindingHandler() {\n          return ctx.onDragEnd();\n        });\n      }\n    },\n    inputs: {\n      draggedElement: [\"treeDrag\", \"draggedElement\"],\n      treeDragEnabled: \"treeDragEnabled\"\n    }\n  });\n  /** @nocollapse */\n\n  return TreeDragDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst EASE_ACCELERATION = 1.005;\nlet TreeAnimateOpenDirective = /*#__PURE__*/(() => {\n  class TreeAnimateOpenDirective {\n    constructor(renderer, templateRef, viewContainerRef) {\n      this.renderer = renderer;\n      this.templateRef = templateRef;\n      this.viewContainerRef = viewContainerRef;\n    }\n\n    set isOpen(value) {\n      if (value) {\n        this._show();\n\n        if (this.isEnabled && this._isOpen === false) {\n          this._animateOpen();\n        }\n      } else {\n        this.isEnabled ? this._animateClose() : this._hide();\n      }\n\n      this._isOpen = !!value;\n    }\n\n    _show() {\n      if (this.innerElement) return; // create child view\n\n      this.innerElement = this.viewContainerRef.createEmbeddedView(this.templateRef).rootNodes[0];\n    }\n\n    _hide() {\n      this.viewContainerRef.clear();\n      this.innerElement = null;\n    }\n\n    _animateOpen() {\n      let delta = this.animateSpeed;\n      let ease = this.animateAcceleration;\n      let maxHeight = 0; // set height to 0\n\n      this.renderer.setStyle(this.innerElement, 'max-height', `0`); // increase maxHeight until height doesn't change\n\n      setTimeout(() => {\n        const i = setInterval(() => {\n          if (!this._isOpen || !this.innerElement) return clearInterval(i);\n          maxHeight += delta;\n          const roundedMaxHeight = Math.round(maxHeight);\n          this.renderer.setStyle(this.innerElement, 'max-height', `${roundedMaxHeight}px`);\n          const height = this.innerElement.getBoundingClientRect ? this.innerElement.getBoundingClientRect().height : 0; // TBD use renderer\n\n          delta *= ease;\n          ease *= EASE_ACCELERATION;\n\n          if (height < roundedMaxHeight) {\n            // Make maxHeight auto because animation finished and container might change height later on\n            this.renderer.setStyle(this.innerElement, 'max-height', null);\n            clearInterval(i);\n          }\n        }, 17);\n      });\n    }\n\n    _animateClose() {\n      if (!this.innerElement) return;\n      let delta = this.animateSpeed;\n      let ease = this.animateAcceleration;\n      let height = this.innerElement.getBoundingClientRect().height; // TBD use renderer\n      // slowly decrease maxHeight to 0, starting from current height\n\n      const i = setInterval(() => {\n        if (this._isOpen || !this.innerElement) return clearInterval(i);\n        height -= delta;\n        this.renderer.setStyle(this.innerElement, 'max-height', `${height}px`);\n        delta *= ease;\n        ease *= EASE_ACCELERATION;\n\n        if (height <= 0) {\n          // after animation complete - remove child element\n          this.viewContainerRef.clear();\n          this.innerElement = null;\n          clearInterval(i);\n        }\n      }, 17);\n    }\n\n  }\n\n  TreeAnimateOpenDirective.ɵfac = function TreeAnimateOpenDirective_Factory(t) {\n    return new (t || TreeAnimateOpenDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef));\n  };\n\n  TreeAnimateOpenDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: TreeAnimateOpenDirective,\n    selectors: [[\"\", \"treeAnimateOpen\", \"\"]],\n    inputs: {\n      isOpen: [\"treeAnimateOpen\", \"isOpen\"],\n      animateSpeed: [\"treeAnimateOpenSpeed\", \"animateSpeed\"],\n      animateAcceleration: [\"treeAnimateOpenAcceleration\", \"animateAcceleration\"],\n      isEnabled: [\"treeAnimateOpenEnabled\", \"isEnabled\"]\n    }\n  });\n  /** @nocollapse */\n\n  return TreeAnimateOpenDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet TreeModule = /*#__PURE__*/(() => {\n  class TreeModule {}\n\n  TreeModule.ɵfac = function TreeModule_Factory(t) {\n    return new (t || TreeModule)();\n  };\n\n  TreeModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: TreeModule\n  });\n  TreeModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    providers: [],\n    imports: [[CommonModule]]\n  });\n  return TreeModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(TreeModule, {\n    declarations: function () {\n      return [TreeComponent, TreeNodeComponent, TreeNodeContent, LoadingComponent, TreeDropDirective, TreeDragDirective, TreeNodeExpanderComponent, TreeNodeChildrenComponent, TreeNodeDropSlot, TreeNodeCollectionComponent, TreeViewportComponent, TreeNodeWrapperComponent, TreeNodeCheckboxComponent, TreeAnimateOpenDirective, TreeMobxAutorunDirective];\n    },\n    imports: function () {\n      return [CommonModule];\n    },\n    exports: function () {\n      return [TreeComponent, TreeNodeComponent, TreeNodeContent, LoadingComponent, TreeDropDirective, TreeDragDirective, TreeNodeExpanderComponent, TreeNodeChildrenComponent, TreeNodeDropSlot, TreeNodeCollectionComponent, TreeViewportComponent, TreeNodeWrapperComponent, TreeNodeCheckboxComponent, TreeAnimateOpenDirective, TreeMobxAutorunDirective];\n    }\n  });\n})();\n/*\r\n * Public API Surface of angular-tree-component\r\n */\n\n/**\r\n * Generated bundle index. Do not edit.\r\n */\n\n\nexport { KEYS, LoadingComponent, TREE_ACTIONS, TreeAnimateOpenDirective, TreeComponent, TreeDragDirective, TreeDraggedElement, TreeDropDirective, TreeModel, TreeModule, TreeNode, TreeNodeCheckboxComponent, TreeNodeChildrenComponent, TreeNodeCollectionComponent, TreeNodeComponent, TreeNodeContent, TreeNodeDropSlot, TreeNodeExpanderComponent, TreeNodeWrapperComponent, TreeViewportComponent, TreeVirtualScroll, actionInternal as ɵa, action as ɵb, computed as ɵc, observable as ɵd, TreeMobxAutorunDirective as ɵe }; //# sourceMappingURL=circlon-angular-tree-component.js.map","map":null,"metadata":{},"sourceType":"module"}