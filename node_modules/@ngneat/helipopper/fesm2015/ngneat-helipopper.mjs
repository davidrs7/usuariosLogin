import * as i0 from '@angular/core';
import { ElementRef, InjectionToken, EventEmitter, Injector, PLATFORM_ID, Directive, Inject, Input, Output, Injectable } from '@angular/core';
import { isPlatformServer } from '@angular/common';
import tippy from 'tippy.js';
import { Observable, Subject, fromEvent, merge } from 'rxjs';
import { auditTime, map, switchMap, takeUntil, filter } from 'rxjs/operators';
import * as i1 from '@ngneat/overview';
import { isString as isString$1, isComponent, isTemplateRef } from '@ngneat/overview';

let supportsIntersectionObserver = false;
let supportsResizeObserver = false;
if (typeof window !== 'undefined') {
    supportsIntersectionObserver = 'IntersectionObserver' in window;
    supportsResizeObserver = 'ResizeObserver' in window;
}
function inView(host, options = {
    root: null,
    threshold: 0.3
}) {
    const element = coerceElement(host);
    return new Observable(subscriber => {
        if (!supportsIntersectionObserver) {
            subscriber.next();
            subscriber.complete();
            return;
        }
        const observer = new IntersectionObserver(entries => {
            // Several changes may occur in the same tick, we want to check the latest entry state.
            const entry = entries[entries.length - 1];
            if (entry.isIntersecting) {
                subscriber.next();
                subscriber.complete();
            }
        }, options);
        observer.observe(element);
        return () => observer.disconnect();
    });
}
function isElementOverflow(host) {
    // Don't access the `offsetWidth` multipe times since it triggers layout updates.
    const hostOffsetWidth = host.offsetWidth;
    return hostOffsetWidth > host.parentElement.offsetWidth || hostOffsetWidth < host.scrollWidth;
}
function overflowChanges(host) {
    const element = coerceElement(host);
    return dimensionsChanges(element).pipe(auditTime(150), map(() => isElementOverflow(element)));
}
function dimensionsChanges(target) {
    return resizeObserverStrategy(target);
}
function resizeObserverStrategy(target) {
    return new Observable(subscriber => {
        if (!supportsResizeObserver) {
            subscriber.next();
            subscriber.complete();
            return;
        }
        const observer = new ResizeObserver(() => subscriber.next(true));
        observer.observe(target);
        return () => observer.disconnect();
    });
}
function onlyTippyProps(allProps) {
    const tippyProps = {};
    const ownProps = [
        'useTextContent',
        'variations',
        'useHostWidth',
        'defaultVariation',
        'beforeRender',
        'lazy',
        'variation',
        'isEnabled',
        'className',
        'onlyTextOverflow',
        'data',
        'content',
        'context',
        'hideOnEscape',
        'customHost',
        'injector',
        'preserveView',
        'vcr',
        'popperWidth'
    ];
    const overriddenMethods = ['onShow', 'onHidden', 'onCreate'];
    Object.keys(allProps).forEach(prop => {
        if (!ownProps.includes(prop) && !overriddenMethods.includes(prop)) {
            tippyProps[prop] = allProps[prop];
        }
    });
    return tippyProps;
}
function normalizeClassName(className) {
    const classes = isString(className) ? className.split(' ') : className;
    return classes.map(klass => klass === null || klass === void 0 ? void 0 : klass.trim()).filter(Boolean);
}
function coerceCssPixelValue(value) {
    if (isNil(value)) {
        return '';
    }
    return typeof value === 'string' ? value : `${value}px`;
}
function isString(value) {
    return typeof value === 'string';
}
function isNil(value) {
    return value === undefined || value === null;
}
function coerceElement(element) {
    return element instanceof ElementRef ? element.nativeElement : element;
}

const TIPPY_CONFIG = new InjectionToken('Tippy config', {
    providedIn: 'root',
    factory() {
        return {};
    }
});
const TIPPY_REF = new InjectionToken('TIPPY_REF');

class TippyDirective {
    constructor(platformId, globalConfig, injector, viewService, vcr, zone, hostRef) {
        this.platformId = platformId;
        this.globalConfig = globalConfig;
        this.injector = injector;
        this.viewService = viewService;
        this.vcr = vcr;
        this.zone = zone;
        this.hostRef = hostRef;
        this.onlyTextOverflow = false;
        this.useHostWidth = false;
        this.hideOnEscape = false;
        this.detectChangesComponent = true;
        this.visible = new EventEmitter();
        this.isVisible = false;
        this.destroyed = new Subject();
        this.enabled = true;
        this.variationDefined = false;
        /**
         * We had use `visible` event emitter previously as a `takeUntil` subscriber in multiple places
         * within the directive.
         * This is for internal use only; thus we don't have to deal with the `visible` event emitter
         * and trigger change detections only when the `visible` event is being listened outside
         * in the template (`<button [tippy]="..." (visible)="..."></button>`).
         */
        this.visibleInternal = new Subject();
    }
    ngOnChanges(changes) {
        if (isPlatformServer(this.platformId))
            return;
        let props = Object.keys(changes).reduce((acc, change) => {
            if (change === 'isVisible')
                return acc;
            acc[change] = changes[change].currentValue;
            return acc;
        }, {});
        let variation;
        if (isChanged('variation', changes)) {
            variation = changes.variation.currentValue;
            this.variationDefined = true;
        }
        else if (!this.variationDefined) {
            variation = this.globalConfig.defaultVariation;
            this.variationDefined = true;
        }
        if (variation) {
            props = Object.assign(Object.assign({}, this.globalConfig.variations[variation]), props);
        }
        if (isChanged('isEnabled', changes)) {
            this.enabled = changes.isEnabled.currentValue;
            this.setStatus();
        }
        if (isChanged('isVisible', changes)) {
            this.isVisible ? this.show() : this.hide();
        }
        this.setProps(Object.assign(Object.assign({}, this.props), props));
    }
    ngOnInit() {
        if (this.useHostWidth) {
            this.props.maxWidth = this.hostWidth;
        }
    }
    ngAfterViewInit() {
        if (isPlatformServer(this.platformId))
            return;
        this.zone.runOutsideAngular(() => {
            if (this.lazy) {
                if (this.onlyTextOverflow) {
                    inView(this.host)
                        .pipe(switchMap(() => overflowChanges(this.host)), takeUntil(this.destroyed))
                        .subscribe(isElementOverflow => {
                        this.checkOverflow(isElementOverflow);
                    });
                }
                else {
                    inView(this.host)
                        .pipe(takeUntil(this.destroyed))
                        .subscribe(() => {
                        this.createInstance();
                    });
                }
            }
            else if (this.onlyTextOverflow) {
                overflowChanges(this.host)
                    .pipe(takeUntil(this.destroyed))
                    .subscribe(isElementOverflow => {
                    this.checkOverflow(isElementOverflow);
                });
            }
            else {
                this.createInstance();
            }
        });
    }
    ngOnDestroy() {
        var _a;
        this.destroyed.next();
        (_a = this.instance) === null || _a === void 0 ? void 0 : _a.destroy();
        this.destroyView();
    }
    destroyView() {
        var _a;
        this.viewOptions$ = null;
        (_a = this.viewRef) === null || _a === void 0 ? void 0 : _a.destroy();
        this.viewRef = null;
    }
    show() {
        var _a;
        (_a = this.instance) === null || _a === void 0 ? void 0 : _a.show();
    }
    hide() {
        var _a;
        (_a = this.instance) === null || _a === void 0 ? void 0 : _a.hide();
    }
    enable() {
        var _a;
        (_a = this.instance) === null || _a === void 0 ? void 0 : _a.enable();
    }
    disable() {
        var _a;
        (_a = this.instance) === null || _a === void 0 ? void 0 : _a.disable();
    }
    setProps(props) {
        var _a;
        this.props = props;
        (_a = this.instance) === null || _a === void 0 ? void 0 : _a.setProps(onlyTippyProps(props));
    }
    setStatus() {
        var _a, _b;
        this.enabled ? (_a = this.instance) === null || _a === void 0 ? void 0 : _a.enable() : (_b = this.instance) === null || _b === void 0 ? void 0 : _b.disable();
    }
    get host() {
        return this.customHost || this.hostRef.nativeElement;
    }
    get hostWidth() {
        return this.host.getBoundingClientRect().width;
    }
    createInstance() {
        if (!this.content && !coerceBooleanInput(this.useTextContent)) {
            return;
        }
        this.zone.runOutsideAngular(() => {
            this.instance = tippy(this.host, Object.assign(Object.assign(Object.assign({ allowHTML: true, appendTo: document.body }, onlyTippyProps(this.globalConfig)), onlyTippyProps(this.props)), { onMount: instance => {
                    var _a, _b;
                    this.isVisible = true;
                    this.visibleInternal.next(this.isVisible);
                    if (this.visible.observed) {
                        this.zone.run(() => this.visible.next(this.isVisible));
                    }
                    this.useHostWidth && this.listenToHostResize();
                    (_b = (_a = this.globalConfig).onMount) === null || _b === void 0 ? void 0 : _b.call(_a, instance);
                }, onCreate: instance => {
                    var _a, _b;
                    instance.popper.classList.add(`tippy-variation-${this.variation || this.globalConfig.defaultVariation}`);
                    if (this.className) {
                        for (const klass of normalizeClassName(this.className)) {
                            instance.popper.classList.add(klass);
                        }
                    }
                    (_b = (_a = this.globalConfig).onCreate) === null || _b === void 0 ? void 0 : _b.call(_a, instance);
                    if (this.isVisible === true) {
                        instance.show();
                    }
                }, onShow: instance => {
                    var _a, _b;
                    instance.reference.setAttribute('data-tippy-open', '');
                    this.zone.run(() => {
                        const content = this.resolveContent(instance);
                        if (isString$1(content)) {
                            instance.setProps({ allowHTML: false });
                            if (!(content === null || content === void 0 ? void 0 : content.trim())) {
                                this.disable();
                            }
                            else {
                                this.enable();
                            }
                        }
                        instance.setContent(content);
                        this.hideOnEscape && this.handleEscapeButton();
                    });
                    if (this.useHostWidth) {
                        this.setInstanceWidth(instance, this.hostWidth);
                    }
                    else if (this.popperWidth) {
                        this.setInstanceWidth(instance, this.popperWidth);
                    }
                    (_b = (_a = this.globalConfig).onShow) === null || _b === void 0 ? void 0 : _b.call(_a, instance);
                }, onHide(instance) {
                    instance.reference.removeAttribute('data-tippy-open');
                }, onHidden: instance => {
                    var _a, _b;
                    this.destroyView();
                    this.isVisible = false;
                    this.visibleInternal.next(this.isVisible);
                    if (this.visible.observed) {
                        this.zone.run(() => this.visible.next(this.isVisible));
                    }
                    (_b = (_a = this.globalConfig).onHidden) === null || _b === void 0 ? void 0 : _b.call(_a, instance);
                } }));
            this.setStatus();
            this.setProps(this.props);
            this.variation === 'contextMenu' && this.handleContextMenu();
        });
    }
    resolveContent(instance) {
        if (!this.viewOptions$ && !isString$1(this.content)) {
            if (isComponent(this.content)) {
                this.instance.data = this.data;
                this.viewOptions$ = {
                    injector: Injector.create({
                        providers: [
                            {
                                provide: TIPPY_REF,
                                useValue: this.instance
                            }
                        ],
                        parent: this.injector
                    })
                };
            }
            else if (isTemplateRef(this.content)) {
                this.viewOptions$ = {
                    context: {
                        $implicit: this.hide.bind(this),
                        data: this.data
                    }
                };
            }
        }
        this.viewRef = this.viewService.createView(this.content, Object.assign({ vcr: this.vcr }, this.viewOptions$));
        // We need to call detectChanges for onPush components to update the content
        if (this.detectChangesComponent && isComponent(this.content)) {
            this.viewRef.detectChanges();
        }
        let content = this.viewRef.getElement();
        if (coerceBooleanInput(this.useTextContent)) {
            content = instance.reference.textContent;
        }
        if (isString$1(content) && this.globalConfig.beforeRender) {
            content = this.globalConfig.beforeRender(content);
        }
        return content;
    }
    handleContextMenu() {
        fromEvent(this.host, 'contextmenu')
            .pipe(takeUntil(this.destroyed))
            .subscribe((event) => {
            event.preventDefault();
            this.instance.setProps({
                getReferenceClientRect: () => ({
                    width: 0,
                    height: 0,
                    top: event.clientY,
                    bottom: event.clientY,
                    left: event.clientX,
                    right: event.clientX
                })
            });
            this.instance.show();
        });
    }
    handleEscapeButton() {
        this.zone.runOutsideAngular(() => {
            fromEvent(document.body, 'keydown')
                .pipe(filter(({ code }) => code === 'Escape'), takeUntil(merge(this.destroyed, this.visibleInternal.pipe(filter(v => !v)))))
                .subscribe(() => this.hide());
        });
    }
    checkOverflow(isElementOverflow) {
        var _a;
        if (isElementOverflow) {
            if (!this.instance) {
                this.createInstance();
            }
            else {
                this.instance.enable();
            }
        }
        else {
            (_a = this.instance) === null || _a === void 0 ? void 0 : _a.disable();
        }
    }
    listenToHostResize() {
        dimensionsChanges(this.host)
            .pipe(takeUntil(merge(this.destroyed, this.visibleInternal)))
            .subscribe(() => {
            this.setInstanceWidth(this.instance, this.hostWidth);
        });
    }
    setInstanceWidth(instance, width) {
        const inPixels = coerceCssPixelValue(width);
        instance.popper.style.width = inPixels;
        instance.popper.style.maxWidth = inPixels;
        instance.popper.firstElementChild.style.maxWidth = inPixels;
    }
}
TippyDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.0.1", ngImport: i0, type: TippyDirective, deps: [{ token: PLATFORM_ID }, { token: TIPPY_CONFIG }, { token: i0.Injector }, { token: i1.ViewService }, { token: i0.ViewContainerRef }, { token: i0.NgZone }, { token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Directive });
TippyDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "15.0.1", type: TippyDirective, isStandalone: true, selector: "[tippy]", inputs: { appendTo: "appendTo", delay: "delay", duration: "duration", hideOnClick: "hideOnClick", interactive: "interactive", interactiveBorder: "interactiveBorder", maxWidth: "maxWidth", offset: "offset", placement: "placement", popperOptions: "popperOptions", showOnCreate: "showOnCreate", trigger: "trigger", triggerTarget: "triggerTarget", zIndex: "zIndex", animation: "animation", useTextContent: "useTextContent", lazy: "lazy", variation: "variation", isEnabled: "isEnabled", className: "className", onlyTextOverflow: "onlyTextOverflow", data: "data", useHostWidth: "useHostWidth", hideOnEscape: "hideOnEscape", detectChangesComponent: "detectChangesComponent", popperWidth: "popperWidth", content: ["tippy", "content"], customHost: ["tippyHost", "customHost"], isVisible: "isVisible" }, outputs: { visible: "visible" }, exportAs: ["tippy"], usesOnChanges: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.0.1", ngImport: i0, type: TippyDirective, decorators: [{
            type: Directive,
            args: [{
                    // eslint-disable-next-line @angular-eslint/directive-selector
                    selector: '[tippy]',
                    exportAs: 'tippy',
                    standalone: true
                }]
        }], ctorParameters: function () {
        return [{ type: undefined, decorators: [{
                        type: Inject,
                        args: [PLATFORM_ID]
                    }] }, { type: undefined, decorators: [{
                        type: Inject,
                        args: [TIPPY_CONFIG]
                    }] }, { type: i0.Injector }, { type: i1.ViewService }, { type: i0.ViewContainerRef }, { type: i0.NgZone }, { type: i0.ElementRef }];
    }, propDecorators: { appendTo: [{
                type: Input
            }], delay: [{
                type: Input
            }], duration: [{
                type: Input
            }], hideOnClick: [{
                type: Input
            }], interactive: [{
                type: Input
            }], interactiveBorder: [{
                type: Input
            }], maxWidth: [{
                type: Input
            }], offset: [{
                type: Input
            }], placement: [{
                type: Input
            }], popperOptions: [{
                type: Input
            }], showOnCreate: [{
                type: Input
            }], trigger: [{
                type: Input
            }], triggerTarget: [{
                type: Input
            }], zIndex: [{
                type: Input
            }], animation: [{
                type: Input
            }], useTextContent: [{
                type: Input
            }], lazy: [{
                type: Input
            }], variation: [{
                type: Input
            }], isEnabled: [{
                type: Input
            }], className: [{
                type: Input
            }], onlyTextOverflow: [{
                type: Input
            }], data: [{
                type: Input
            }], useHostWidth: [{
                type: Input
            }], hideOnEscape: [{
                type: Input
            }], detectChangesComponent: [{
                type: Input
            }], popperWidth: [{
                type: Input
            }], content: [{
                type: Input,
                args: ['tippy']
            }], customHost: [{
                type: Input,
                args: ['tippyHost']
            }], visible: [{
                type: Output
            }], isVisible: [{
                type: Input
            }] } });
function isChanged(key, changes) {
    return key in changes;
}
function coerceBooleanInput(value) {
    return value != null && `${value}` !== 'false';
}

const tooltipVariation = {
    theme: null,
    arrow: false,
    animation: 'scale',
    trigger: 'mouseenter',
    offset: [0, 5]
};
const popperVariation = {
    theme: 'light',
    arrow: true,
    offset: [0, 10],
    animation: null,
    trigger: 'click',
    interactive: true
};
function withContextMenuVariation(baseVariation) {
    return Object.assign(Object.assign({}, baseVariation), { placement: 'right-start', trigger: 'manual', arrow: false, offset: [0, 0] });
}

class TippyService {
    constructor(globalConfig, view, injector) {
        this.globalConfig = globalConfig;
        this.view = view;
        this.injector = injector;
    }
    create(host, content, options = {}) {
        const variation = options.variation || this.globalConfig.defaultVariation;
        const config = Object.assign(Object.assign(Object.assign(Object.assign({ onShow: instance => {
                var _a;
                host.setAttribute('data-tippy-open', '');
                if (!instance.$viewOptions) {
                    instance.$viewOptions = {};
                    if (isTemplateRef(content)) {
                        instance.$viewOptions.context = Object.assign({ $implicit: instance.hide.bind(instance) }, options.context);
                    }
                    else if (isComponent(content)) {
                        instance.context = options.context;
                        instance.data = options.data;
                        instance.$viewOptions.injector = Injector.create({
                            providers: [
                                {
                                    provide: TIPPY_REF,
                                    useValue: instance
                                }
                            ],
                            parent: options.injector || this.injector
                        });
                    }
                }
                if (!instance.view) {
                    instance.view = this.view.createView(content, Object.assign(Object.assign({}, options), instance.$viewOptions));
                }
                instance.setContent(instance.view.getElement());
                (_a = options === null || options === void 0 ? void 0 : options.onShow) === null || _a === void 0 ? void 0 : _a.call(options, instance);
            }, onHidden: instance => {
                var _a;
                host.removeAttribute('data-tippy-open');
                if (!options.preserveView) {
                    instance.view.destroy();
                    instance.view = null;
                }
                (_a = options === null || options === void 0 ? void 0 : options.onHidden) === null || _a === void 0 ? void 0 : _a.call(options, instance);
            } }, onlyTippyProps(this.globalConfig)), this.globalConfig.variations[variation]), onlyTippyProps(options)), { onCreate: instance => {
                var _a, _b, _c;
                instance.popper.classList.add(`tippy-variation-${variation}`);
                if (options.className) {
                    for (const klass of normalizeClassName(options.className)) {
                        instance.popper.classList.add(klass);
                    }
                }
                (_b = (_a = this.globalConfig).onCreate) === null || _b === void 0 ? void 0 : _b.call(_a, instance);
                (_c = options.onCreate) === null || _c === void 0 ? void 0 : _c.call(options, instance);
            } });
        return tippy(host, config);
    }
}
TippyService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.0.1", ngImport: i0, type: TippyService, deps: [{ token: TIPPY_CONFIG }, { token: i1.ViewService }, { token: i0.Injector }], target: i0.ɵɵFactoryTarget.Injectable });
TippyService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.0.1", ngImport: i0, type: TippyService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.0.1", ngImport: i0, type: TippyService, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }], ctorParameters: function () {
        return [{ type: undefined, decorators: [{
                        type: Inject,
                        args: [TIPPY_CONFIG]
                    }] }, { type: i1.ViewService }, { type: i0.Injector }];
    } });

function provideTippyConfig(config = {}) {
    return {
        provide: TIPPY_CONFIG,
        useValue: config
    };
}

/**
 * Generated bundle index. Do not edit.
 */

export { TIPPY_CONFIG, TIPPY_REF, TippyDirective, TippyService, inView, overflowChanges, popperVariation, provideTippyConfig, tooltipVariation, withContextMenuVariation };
//# sourceMappingURL=ngneat-helipopper.mjs.map
