import { AfterViewInit, ElementRef, EventEmitter, Injector, NgZone, OnChanges, OnDestroy, OnInit, ViewContainerRef } from '@angular/core';
import { Instance } from 'tippy.js';
import { Subject } from 'rxjs';
import { Content, ViewOptions, ViewRef, ViewService } from '@ngneat/overview';
import { NgChanges, TippyConfig, TippyInstance, TippyProps } from './tippy.types';
import * as i0 from "@angular/core";
export declare class TippyDirective implements OnChanges, AfterViewInit, OnDestroy, OnInit {
    protected platformId: string;
    protected globalConfig: TippyConfig;
    protected injector: Injector;
    protected viewService: ViewService;
    protected vcr: ViewContainerRef;
    protected zone: NgZone;
    protected hostRef: ElementRef;
    static ngAcceptInputType_useTextContent: boolean | '';
    appendTo: TippyProps['appendTo'];
    delay: TippyProps['delay'];
    duration: TippyProps['duration'];
    hideOnClick: TippyProps['hideOnClick'];
    interactive: TippyProps['interactive'];
    interactiveBorder: TippyProps['interactiveBorder'];
    maxWidth: TippyProps['maxWidth'];
    offset: TippyProps['offset'];
    placement: TippyProps['placement'];
    popperOptions: TippyProps['popperOptions'];
    showOnCreate: TippyProps['showOnCreate'];
    trigger: TippyProps['trigger'];
    triggerTarget: TippyProps['triggerTarget'];
    zIndex: TippyProps['zIndex'];
    animation: TippyProps['animation'];
    useTextContent: boolean;
    lazy: boolean;
    variation: string;
    isEnabled: boolean;
    className: string | string[];
    onlyTextOverflow: boolean;
    data: any;
    useHostWidth: boolean;
    hideOnEscape: boolean;
    detectChangesComponent: boolean;
    popperWidth: number | string;
    content: Content | undefined | null;
    customHost: HTMLElement;
    visible: EventEmitter<boolean>;
    isVisible: boolean;
    protected instance: TippyInstance;
    protected viewRef: ViewRef;
    protected destroyed: Subject<void>;
    protected props: Partial<TippyConfig>;
    protected enabled: boolean;
    protected variationDefined: boolean;
    protected viewOptions$: ViewOptions;
    /**
     * We had use `visible` event emitter previously as a `takeUntil` subscriber in multiple places
     * within the directive.
     * This is for internal use only; thus we don't have to deal with the `visible` event emitter
     * and trigger change detections only when the `visible` event is being listened outside
     * in the template (`<button [tippy]="..." (visible)="..."></button>`).
     */
    protected visibleInternal: Subject<boolean>;
    constructor(platformId: string, globalConfig: TippyConfig, injector: Injector, viewService: ViewService, vcr: ViewContainerRef, zone: NgZone, hostRef: ElementRef);
    ngOnChanges(changes: NgChanges<TippyDirective>): void;
    ngOnInit(): void;
    ngAfterViewInit(): void;
    ngOnDestroy(): void;
    destroyView(): void;
    show(): void;
    hide(): void;
    enable(): void;
    disable(): void;
    protected setProps(props: Partial<TippyConfig>): void;
    protected setStatus(): void;
    protected get host(): HTMLElement;
    protected get hostWidth(): number;
    protected createInstance(): void;
    protected resolveContent(instance: TippyInstance): string | Element;
    protected handleContextMenu(): void;
    protected handleEscapeButton(): void;
    protected checkOverflow(isElementOverflow: boolean): void;
    protected listenToHostResize(): void;
    protected setInstanceWidth(instance: Instance, width: string | number): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<TippyDirective, never>;
    static ɵdir: i0.ɵɵDirectiveDeclaration<TippyDirective, "[tippy]", ["tippy"], { "appendTo": "appendTo"; "delay": "delay"; "duration": "duration"; "hideOnClick": "hideOnClick"; "interactive": "interactive"; "interactiveBorder": "interactiveBorder"; "maxWidth": "maxWidth"; "offset": "offset"; "placement": "placement"; "popperOptions": "popperOptions"; "showOnCreate": "showOnCreate"; "trigger": "trigger"; "triggerTarget": "triggerTarget"; "zIndex": "zIndex"; "animation": "animation"; "useTextContent": "useTextContent"; "lazy": "lazy"; "variation": "variation"; "isEnabled": "isEnabled"; "className": "className"; "onlyTextOverflow": "onlyTextOverflow"; "data": "data"; "useHostWidth": "useHostWidth"; "hideOnEscape": "hideOnEscape"; "detectChangesComponent": "detectChangesComponent"; "popperWidth": "popperWidth"; "content": "tippy"; "customHost": "tippyHost"; "isVisible": "isVisible"; }, { "visible": "visible"; }, never, never, true, never>;
}
export declare function coerceBooleanInput(value: any): boolean;
